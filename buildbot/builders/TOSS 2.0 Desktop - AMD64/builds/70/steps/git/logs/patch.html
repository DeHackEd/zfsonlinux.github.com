<html>

<!-- Mirrored from pip.chaos:8010/builders/TOSS%202.0%20Desktop%20-%20AMD64/builds/70/steps/git/logs/patch by HTTrack Website Copier/3.x [XR&CO'2010], Fri, 08 Jul 2011 00:43:47 GMT -->
<head><title>Log File contents</title>

<style type="text/css">
 div.data {
  font-family: "Courier New", courier, monotype;
 }
 span.stdout {
  font-family: "Courier New", courier, monotype;
 }
 span.stderr {
  font-family: "Courier New", courier, monotype;
  color: red;
 }
 span.header {
  font-family: "Courier New", courier, monotype;
  color: blue;
 }
</style>
</head>
<body vlink="#800080">
<a href="patch/texthtml.html">(view as text)</a><br />
<pre>
<span class="stdout">diff --git a/cmd/zpool/zpool_main.c b/cmd/zpool/zpool_main.c
index b1bf5bd..ce95bfe 100644
--- a/cmd/zpool/zpool_main.c
+++ b/cmd/zpool/zpool_main.c
@@ -2358,42 +2358,48 @@ zpool_do_iostat(int argc, char **argv)
 		pool_list_update(list);
 
 		if ((npools = pool_list_count(list)) == 0)
-			break;
-
-		/*
-		 * Refresh all statistics.  This is done as an explicit step
-		 * before calculating the maximum name width, so that any
-		 * configuration changes are properly accounted for.
-		 */
-		(void) pool_list_iter(list, B_FALSE, refresh_iostat, &amp;cb);
+			(void) printf(gettext(&quot;no pools available\n&quot;));
+		else {
+			/*
+			 * Refresh all statistics.  This is done as an
+			 * explicit step before calculating the maximum name
+			 * width, so that any * configuration changes are
+			 * properly accounted for.
+			 */
+			(void) pool_list_iter(list, B_FALSE, refresh_iostat,
+				&amp;cb);
 
-		/*
-		 * Iterate over all pools to determine the maximum width
-		 * for the pool / device name column across all pools.
-		 */
-		cb.cb_namewidth = 0;
-		(void) pool_list_iter(list, B_FALSE, get_namewidth, &amp;cb);
+			/*
+			 * Iterate over all pools to determine the maximum width
+			 * for the pool / device name column across all pools.
+			 */
+			cb.cb_namewidth = 0;
+			(void) pool_list_iter(list, B_FALSE, get_namewidth,
+				&amp;cb);
 
-		if (timestamp_fmt != NODATE)
-			print_timestamp(timestamp_fmt);
+			if (timestamp_fmt != NODATE)
+				print_timestamp(timestamp_fmt);
 
-		/*
-		 * If it's the first time, or verbose mode, print the header.
-		 */
-		if (++cb.cb_iteration == 1 || verbose)
-			print_iostat_header(&amp;cb);
+			/*
+			 * If it's the first time, or verbose mode, print the
+			 * header.
+			 */
+			if (++cb.cb_iteration == 1 || verbose)
+				print_iostat_header(&amp;cb);
 
-		(void) pool_list_iter(list, B_FALSE, print_iostat, &amp;cb);
+			(void) pool_list_iter(list, B_FALSE, print_iostat, &amp;cb);
 
-		/*
-		 * If there's more than one pool, and we're not in verbose mode
-		 * (which prints a separator for us), then print a separator.
-		 */
-		if (npools &gt; 1 &amp;&amp; !verbose)
-			print_iostat_separator(&amp;cb);
+			/*
+			 * If there's more than one pool, and we're not in
+			 * verbose mode (which prints a separator for us),
+			 * then print a separator.
+			 */
+			if (npools &gt; 1 &amp;&amp; !verbose)
+				print_iostat_separator(&amp;cb);
 
-		if (verbose)
-			(void) printf(&quot;\n&quot;);
+			if (verbose)
+				(void) printf(&quot;\n&quot;);
+		}
 
 		/*
 		 * Flush the output so that redirection to a file isn't buffered
@@ -2592,10 +2598,12 @@ zpool_do_list(int argc, char **argv)
 		ret = for_each_pool(argc, argv, B_TRUE, &amp;cb.cb_proplist,
 		    list_callback, &amp;cb);
 
-		if (argc == 0 &amp;&amp; cb.cb_first &amp;&amp; !cb.cb_scripted) {
+		if (argc == 0 &amp;&amp; cb.cb_first)
 			(void) printf(gettext(&quot;no pools available\n&quot;));
+		else if (argc &amp;&amp; cb.cb_first) {
+			/* cannot open the given pool */
 			zprop_free_list(cb.cb_proplist);
-			return (0);
+			return (1);
 		}
 
 		if (interval == 0)
diff --git a/configure b/configure
index 497c993..9eaa373 100755
--- a/configure
+++ b/configure
@@ -20555,7 +20555,7 @@ fi
 $as_echo &quot;$enable_debug&quot; &gt;&amp;6; }
 
 
-ac_config_files=&quot;$ac_config_files Makefile dracut/Makefile dracut/90zfs/Makefile etc/Makefile etc/udev/Makefile etc/udev/rules.d/Makefile etc/init.d/Makefile etc/zfs/Makefile man/Makefile man/man8/Makefile lib/Makefile lib/libspl/Makefile lib/libspl/asm-generic/Makefile lib/libspl/asm-i386/Makefile lib/libspl/asm-x86_64/Makefile lib/libspl/include/Makefile lib/libspl/include/ia32/Makefile lib/libspl/include/ia32/sys/Makefile lib/libspl/include/rpc/Makefile lib/libspl/include/sys/Makefile lib/libspl/include/sys/sysevent/Makefile lib/libspl/include/sys/dktp/Makefile lib/libspl/include/util/Makefile lib/libavl/Makefile lib/libefi/Makefile lib/libnvpair/Makefile lib/libunicode/Makefile lib/libuutil/Makefile lib/libzpool/Makefile lib/libzfs/Makefile cmd/Makefile cmd/zdb/Makefile cmd/zfs/Makefile cmd/zinject/Makefile cmd/zpool/Makefile cmd/ztest/Makefile cmd/zpios/Makefile cmd/mount_zfs/Makefile cmd/zpool_layout/Makefile cmd/zvol_id/Makefile cmd/zpool_id/Makefile cmd/sas_switch_id/Makefile module/Makefile module/avl/Makefile module/nvpair/Makefile module/unicode/Makefile module/zcommon/Makefile module/zfs/Makefile module/zpios/Makefile include/Makefile include/linux/Makefile include/sys/Makefile include/sys/fs/Makefile include/sys/fm/Makefile include/sys/fm/fs/Makefile scripts/Makefile scripts/zpios-profile/Makefile scripts/zpios-test/Makefile scripts/zpool-config/Makefile scripts/zpool-layout/Makefile scripts/common.sh zfs.spec zfs-modules.spec zfs-script-config.sh&quot;
+ac_config_files=&quot;$ac_config_files Makefile dracut/Makefile dracut/90zfs/Makefile etc/Makefile etc/udev/Makefile etc/udev/rules.d/Makefile etc/init.d/Makefile etc/zfs/Makefile man/Makefile man/man8/Makefile lib/Makefile lib/libspl/Makefile lib/libspl/asm-generic/Makefile lib/libspl/asm-i386/Makefile lib/libspl/asm-x86_64/Makefile lib/libspl/include/Makefile lib/libspl/include/ia32/Makefile lib/libspl/include/ia32/sys/Makefile lib/libspl/include/rpc/Makefile lib/libspl/include/sys/Makefile lib/libspl/include/sys/sysevent/Makefile lib/libspl/include/sys/dktp/Makefile lib/libspl/include/util/Makefile lib/libavl/Makefile lib/libefi/Makefile lib/libnvpair/Makefile lib/libunicode/Makefile lib/libuutil/Makefile lib/libzpool/Makefile lib/libzfs/Makefile lib/libshare/Makefile cmd/Makefile cmd/zdb/Makefile cmd/zfs/Makefile cmd/zinject/Makefile cmd/zpool/Makefile cmd/ztest/Makefile cmd/zpios/Makefile cmd/mount_zfs/Makefile cmd/zpool_layout/Makefile cmd/zvol_id/Makefile cmd/zpool_id/Makefile cmd/sas_switch_id/Makefile module/Makefile module/avl/Makefile module/nvpair/Makefile module/unicode/Makefile module/zcommon/Makefile module/zfs/Makefile module/zpios/Makefile include/Makefile include/linux/Makefile include/sys/Makefile include/sys/fs/Makefile include/sys/fm/Makefile include/sys/fm/fs/Makefile scripts/Makefile scripts/zpios-profile/Makefile scripts/zpios-test/Makefile scripts/zpool-config/Makefile scripts/zpool-layout/Makefile scripts/common.sh zfs.spec zfs-modules.spec zfs-script-config.sh&quot;
 
 
 cat &gt;confcache &lt;&lt;\_ACEOF
@@ -21501,6 +21501,7 @@ do
     &quot;lib/libuutil/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES lib/libuutil/Makefile&quot; ;;
     &quot;lib/libzpool/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES lib/libzpool/Makefile&quot; ;;
     &quot;lib/libzfs/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES lib/libzfs/Makefile&quot; ;;
+    &quot;lib/libshare/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES lib/libshare/Makefile&quot; ;;
     &quot;cmd/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES cmd/Makefile&quot; ;;
     &quot;cmd/zdb/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES cmd/zdb/Makefile&quot; ;;
     &quot;cmd/zfs/Makefile&quot;) CONFIG_FILES=&quot;$CONFIG_FILES cmd/zfs/Makefile&quot; ;;
diff --git a/configure.ac b/configure.ac
index 33654de..fda9faf 100644
--- a/configure.ac
+++ b/configure.ac
@@ -84,6 +84,7 @@ AC_CONFIG_FILES([
 	lib/libuutil/Makefile
 	lib/libzpool/Makefile
 	lib/libzfs/Makefile
+	lib/libshare/Makefile
 	cmd/Makefile
 	cmd/zdb/Makefile
 	cmd/zfs/Makefile
diff --git a/dracut/90zfs/90-zfs.rules b/dracut/90zfs/90-zfs.rules
index 918d726..52e1d63 100644
--- a/dracut/90zfs/90-zfs.rules
+++ b/dracut/90zfs/90-zfs.rules
@@ -4,4 +4,7 @@ ACTION!=&quot;add|change&quot;, GOTO=&quot;zfs_end&quot;
 ENV{ID_FS_TYPE}==&quot;zfs&quot;, RUN+=&quot;/sbin/modprobe zfs&quot;
 ENV{ID_FS_TYPE}==&quot;zfs_member&quot;, RUN+=&quot;/sbin/modprobe zfs&quot;
 
+KERNEL==&quot;null&quot;, SYMLINK+=&quot;root&quot;
+SYMLINK==&quot;null&quot;, SYMLINK+=&quot;root&quot;
+
 LABEL=&quot;zfs_end&quot;
diff --git a/dracut/90zfs/Makefile.am b/dracut/90zfs/Makefile.am
index e2e3ff8..605654c 100644
--- a/dracut/90zfs/Makefile.am
+++ b/dracut/90zfs/Makefile.am
@@ -1,11 +1,8 @@
 pkgdracutdir = $(datadir)/dracut/modules.d/90zfs
 dist_pkgdracut_SCRIPTS = \
 	$(top_srcdir)/dracut/90zfs/90-zfs.rules \
-	$(top_srcdir)/dracut/90zfs/check \
-	$(top_srcdir)/dracut/90zfs/install \
-	$(top_srcdir)/dracut/90zfs/installkernel \
+	$(top_srcdir)/dracut/90zfs/module-setup.sh \
 	$(top_srcdir)/dracut/90zfs/mount-zfs.sh \
-	$(top_srcdir)/dracut/90zfs/zfs-genrules.sh \
 	$(top_srcdir)/dracut/90zfs/parse-zfs.sh
 
 all:
diff --git a/dracut/90zfs/Makefile.in b/dracut/90zfs/Makefile.in
index 49ed262..aa40fe5 100644
--- a/dracut/90zfs/Makefile.in
+++ b/dracut/90zfs/Makefile.in
@@ -289,11 +289,8 @@ top_srcdir = @top_srcdir@
 pkgdracutdir = $(datadir)/dracut/modules.d/90zfs
 dist_pkgdracut_SCRIPTS = \
 	$(top_srcdir)/dracut/90zfs/90-zfs.rules \
-	$(top_srcdir)/dracut/90zfs/check \
-	$(top_srcdir)/dracut/90zfs/install \
-	$(top_srcdir)/dracut/90zfs/installkernel \
+	$(top_srcdir)/dracut/90zfs/module-setup.sh \
 	$(top_srcdir)/dracut/90zfs/mount-zfs.sh \
-	$(top_srcdir)/dracut/90zfs/zfs-genrules.sh \
 	$(top_srcdir)/dracut/90zfs/parse-zfs.sh
 
 all: all-am
diff --git a/dracut/90zfs/check b/dracut/90zfs/check
deleted file mode 100755
index ac4006b..0000000
--- a/dracut/90zfs/check
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash
-
-# We depend on udev-rules being loaded
-[ &quot;$1&quot; = &quot;-d&quot; ] &amp;&amp; exit 0
-
-# Verify the zfs tool chain
-which zpool &gt;/dev/null 2&gt;&amp;1 || exit 1
-which zfs &gt;/dev/null 2&gt;&amp;1 || exit 1
-
-exit 0
diff --git a/dracut/90zfs/install b/dracut/90zfs/install
deleted file mode 100755
index 5be9768..0000000
--- a/dracut/90zfs/install
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash
-
-inst_rules &quot;$moddir/90-zfs.rules&quot;
-inst_rules /etc/udev/rules.d/60-zpool.rules
-inst_rules /etc/udev/rules.d/60-zvol.rules
-inst /etc/zfs/zdev.conf
-inst /etc/hostid
-dracut_install zfs
-dracut_install zpool
-dracut_install zpool_layout
-dracut_install zpool_id
-dracut_install zvol_id
-dracut_install mount.zfs
-dracut_install hostid
-inst_hook cmdline 95 &quot;$moddir/parse-zfs.sh&quot;
-inst_hook mount 98 &quot;$moddir/mount-zfs.sh&quot;
-inst_hook pre-udev 29 &quot;$moddir/zfs-genrules.sh&quot;
diff --git a/dracut/90zfs/installkernel b/dracut/90zfs/installkernel
deleted file mode 100755
index c3fa7de..0000000
--- a/dracut/90zfs/installkernel
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash
-
-instmods zfs
-instmods zcommon
-instmods znvpair
-instmods zavl
-instmods zunicode
-instmods spl
-instmods zli</span><span class="stdout">b_deflate
-instmods zlib_inflate
diff --git a/dracut/90zfs/module-setup.sh b/dracut/90zfs/module-setup.sh
new file mode 100755
index 0000000..1816b38
--- /dev/null
+++ b/dracut/90zfs/module-setup.sh
@@ -0,0 +1,46 @@
+#!/bin/sh
+
+check() {
+  # We depend on udev-rules being loaded
+  [ &quot;$1&quot; = &quot;-d&quot; ] &amp;&amp; return 0
+
+  # Verify the zfs tool chain
+  which zpool &gt;/dev/null 2&gt;&amp;1 || return 1
+  which zfs &gt;/dev/null 2&gt;&amp;1 || return 1
+
+  return 0
+}
+
+depends() {
+  echo udev-rules
+  return 0
+}
+
+installkernel() {
+  instmods zfs
+  instmods zcommon
+  instmods znvpair
+  instmods zavl
+  instmods zunicode
+  instmods spl
+  instmods zlib_deflate
+  instmods zlib_inflate
+}
+
+install() {
+  inst_rules &quot;$moddir/90-zfs.rules&quot;
+  inst_rules /etc/udev/rules.d/60-zpool.rules
+  inst_rules /etc/udev/rules.d/60-zvol.rules
+  inst /etc/zfs/zdev.conf
+  inst /etc/zfs/zpool.cache
+  inst /etc/hostid
+  dracut_install zfs
+  dracut_install zpool
+  dracut_install zpool_layout
+  dracut_install zpool_id
+  dracut_install zvol_id
+  dracut_install mount.zfs
+  dracut_install hostid
+  inst_hook cmdline 95 &quot;$moddir/parse-zfs.sh&quot;
+  inst_hook mount 98 &quot;$moddir/mount-zfs.sh&quot;
+}
diff --git a/dracut/90zfs/mount-zfs.sh b/dracut/90zfs/mount-zfs.sh
index b4a4de6..e067c18 100755
--- a/dracut/90zfs/mount-zfs.sh
+++ b/dracut/90zfs/mount-zfs.sh
@@ -2,15 +2,67 @@
 
 . /lib/dracut-lib.sh
 
-if [ &quot;$rootfs&quot; = &quot;zfs&quot; ]; then
-    zfsrootfs=`echo &quot;$root&quot; | sed 's|^zfs:||'`
-    zfspool=`echo &quot;$zfsrootfs&quot; | sed 's|/.*||g'`
-    zpool import -N &quot;$zfspool&quot;
-    mount -o zfsutil -t &quot;$rootfs&quot; &quot;$zfsrootfs&quot; &quot;$NEWROOT&quot;
-    if [ &quot;$?&quot; = &quot;0&quot; ]
-    then
-        ROOTFS_MOUNTED=yes
+ZPOOL_FORCE=&quot;&quot;
+if getargbool 0 zfs_force -y zfs.force -y zfsforce ; then
+  warn &quot;ZFS: Will force-import pools if necessary.&quot;
+  ZPOOL_FORCE=&quot;-f&quot;
+fi
+
+case &quot;$root&quot; in
+  zfs:*)
+    # We have ZFS modules loaded, so we're able to import pools now.
+    if [ &quot;$root&quot; = &quot;zfs:AUTO&quot; ] ; then
+      # Need to parse bootfs attribute
+      info &quot;ZFS: Attempting to detect root from imported ZFS pools.&quot;
+
+      # Might be imported by the kernel module, so try searching before
+      # we import anything.
+      zfsbootfs=`zpool list -H -o bootfs | sed 'q'`
+      if [ &quot;$zfsbootfs&quot; = &quot;&quot; ] ; then
+        # Not there, so we need to import everything.
+        info &quot;ZFS: Attempting to import additional pools.&quot;
+        zpool import -N -a ${ZPOOL_FORCE}
+        zfsbootfs=`zpool list -H -o bootfs | sed 'q'`
+        if [ &quot;$zfsbootfs&quot; = &quot;&quot; ] ; then
+          rootok=0
+          pool=&quot;&quot;
+
+          warn &quot;ZFS: No bootfs attribute found in importable pools.&quot;
+
+          # Re-export everything since we're not prepared to take
+          # responsibility for them.
+          zpool list -H | while read fs rest ; do
+            zpool export &quot;$fs&quot;
+          done
+
+          return 1
+        fi
+      fi
+      info &quot;ZFS: Using ${zfsbootfs} as root.&quot;
     else
-        mount -t &quot;$rootfs&quot; &quot;$zfsrootfs&quot; &quot;$NEWROOT&quot; &amp;&amp; ROOTFS_MOUNTED=yes
+      # Should have an explicit pool set, so just import it and we're done.
+      zfsbootfs=&quot;${root#zfs:}&quot;
+      pool=&quot;${zfsbootfs%%/*}&quot;
+      if ! zpool list -H $pool &gt; /dev/null ; then
+        # pool wasn't imported automatically by the kernel module, so
+        # try it manually.
+        info &quot;ZFS: Importing pool ${pool}...&quot;
+        if ! zpool import -N ${ZPOOL_FORCE} $pool ; then
+          warn &quot;ZFS: Unable to import pool ${pool}.&quot;
+          rootok=0
+
+          return 1
+        fi
+      fi
     fi
-fi
+
+    # Above should have left our rpool imported and pool/dataset in $root.
+    # We need zfsutil for non-legacy mounts and not for legacy mounts.
+    mountpoint=`zfs get -H -o value mountpoint $zfsbootfs`
+    if [ &quot;$mountpoint&quot; = &quot;legacy&quot; ] ; then
+      mount -t zfs &quot;$zfsbootfs&quot; &quot;$NEWROOT&quot; &amp;&amp; ROOTFS_MOUNTED=yes
+    else
+      mount -o zfsutil -t zfs &quot;$zfsbootfs&quot; &quot;$NEWROOT&quot; &amp;&amp; ROOTFS_MOUNTED=yes
+    fi
+    ;;
+esac
diff --git a/dracut/90zfs/parse-zfs.sh b/dracut/90zfs/parse-zfs.sh
index ef3d058..f8974b9 100755
--- a/dracut/90zfs/parse-zfs.sh
+++ b/dracut/90zfs/parse-zfs.sh
@@ -1,23 +1,49 @@
+#!/bin/sh
+
+. /lib/dracut-lib.sh
+
+# Let the command line override our host id.
+spl_hostid=`getarg spl_hostid=`
+if [ &quot;${spl_hostid}&quot; != &quot;&quot; ] ; then
+  info &quot;ZFS: Using hostid from command line: ${spl_hostid}&quot;
+  echo &quot;${spl_hostid}&quot; &gt; /etc/hostid
+elif [ -f /etc/hostid ] ; then
+  info &quot;ZFS: Using hostid from /etc/hostid: `cat /etc/hostid`&quot;
+else
+  warn &quot;ZFS: No hostid found on kernel command line or /etc/hostid.  ZFS pools may not import correctly.&quot;
+fi
+
 case &quot;$root&quot; in
-    zfs:FILESYSTEM=*|FILESYSTEM=*)
-	root=&quot;${root#zfs:}&quot;
-	root=&quot;zfs:${root#FILESYSTEM=}&quot;
-        rootfs=&quot;zfs&quot;
-        rootok=1 ;;
-    zfs:ZFS=*|ZFS=*)
-	root=&quot;${root#zfs:}&quot;
-	root=&quot;zfs:${root#ZFS=}&quot;
-        rootfs=&quot;zfs&quot;
-        rootok=1 ;;
+  &quot;&quot;|zfs|zfs:)
+    # We'll take root unset, root=zfs, or root=zfs:
+    # No root set, so we want to read the bootfs attribute.  We can't do
+    # that until udev settles so we'll set dummy values and hope for the
+    # best later on.
+    root=&quot;zfs:AUTO&quot;
+    rootok=1
+
+    info &quot;ZFS: Enabling autodetection of bootfs after udev settles.&quot;
+    ;;
+
+  ZFS\=*|zfs:*|zfs:FILESYSTEM\=*|FILESYSTEM\=*)
+    # root is explicit ZFS root.  Parse it now.
+    # We can handle a root=... param in any of the following formats:
+    # root=ZFS=rpool/ROOT
+    # root=zfs:rpool/ROOT
+    # root=zfs:FILESYSTEM=rpool/ROOT
+    # root=FILESYSTEM=rpool/ROOT
+
+    # Strip down to just the pool/fs
+    root=&quot;${root#zfs:}&quot;
+    root=&quot;${root#FILESYSTEM=}&quot;
+    root=&quot;zfs:${root#ZFS=}&quot;
+    rootok=1
+
+    info &quot;ZFS: Set ${root} as bootfs.&quot;
+    ;;
 esac
 
-if [ &quot;$rootok&quot; != &quot;1&quot; ] ; then
-	zpool import -aN
-	zfsbootfs=`zpool list -H -o bootfs | grep -v ^-$ -m 1`
-	if [ -n &quot;$zfsbootfs&quot; ] ; then
-		root=&quot;zfs:$zfsbootfs&quot;
-		rootfs=&quot;zfs&quot;
-		rootok=1
-	fi
-	zpool list -H | while read fs rest ; do zpool export &quot;$fs&quot; ; done
-fi
+# Make sure Dracut is happy that we have a root and will wait for ZFS
+# modules to settle before mounting.
+ln -s /dev/null /dev/root 2&gt;/dev/null
+echo '[ -e /dev/zfs ]' &gt; $hookdir/initqueue/finished/zfs.sh
diff --git a/dracut/90zfs/zfs-genrules.sh b/dracut/90zfs/zfs-genrules.sh
deleted file mode 100755
index ffbd51f..0000000
--- a/dracut/90zfs/zfs-genrules.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-if [ &quot;${root%%:*}&quot; = &quot;zfs&quot; ]; then
-    [ -d /dev/.udev/rules.d ] || mkdir -p /dev/.udev/rules.d
-    {
-    printf 'KERNEL==&quot;%s&quot;, SYMLINK+=&quot;root&quot;\n' null 
-    printf 'SYMLINK==&quot;%s&quot;, SYMLINK+=&quot;root&quot;\n' null 
-    } &gt;&gt; /dev/.udev/rules.d/99-zfs.rules
-    
-    printf '[ -e &quot;%s&quot; ] &amp;&amp; { ln -s &quot;%s&quot; /dev/root 2&gt;/dev/null; rm &quot;$job&quot;; }\n' \
-	&quot;/dev/null&quot; &quot;/dev/null&quot; &gt;&gt; /initqueue-settled/zfssymlink.sh
-
-    echo '[ -e /dev/root ]' &gt; /initqueue-finished/zfs.sh
-fi
diff --git a/dracut/README.dracut.markdown b/dracut/README.dracut.markdown
index 8ec28e4..2628438 100644
--- a/dracut/README.dracut.markdown
+++ b/dracut/README.dracut.markdown
@@ -26,3 +26,140 @@ zfs_arc_max, zfs_prefetch_disable, and zfs_vdev_max_pending.
 4) Finally, create your new initramfs by running dracut.
 
     $ dracut --force /path/to/initramfs kernel_version
+
+Kernel Command Line
+-------------------
+
+The initramfs' behavior is influenced by the following kernel command line
+parameters passed in from the boot loader:
+
+* `root=...`: If not set, importable pools are searched for a bootfs attribute.
+If an explicitly set root is desired, you may use `root=ZFS:pool/dataset`
+
+* `zfs_force=0`: If set to 1, the initramfs will run `zpool import -f` when
+attempting to import pools if the required pool isn't automatically imported
+by the zfs module.  This can save you a trip to a bootcd if hostid has changed,
+but is dangerous and can lead to zpool corruption, particularly in cases where
+storage is on a shared fabric such as iSCSI where multiple hosts can access
+storage devices concurrently.  _Please understand the implications of
+force-importing a pool before enabling this option!_
+
+* `spl_hostid`: By default, the hostid used by the SPL module is read from
+/etc/hostid inside the initramfs.  This file is placed there from the host
+system when the initramfs is built which effectively ties the ramdisk to the
+host which builds it.  If a different hostid is desired, one may be set in
+this attribute and will override any file present in the ramdisk.  The
+format should be hex exactly as found in the `/etc/hostid` file, IE
+`spl_hostid=0x00bab10c`.
+
+Note that changing the hostid between boots will most likely lead to an
+un-importable pool since the last importing hostid won't match.  In order
+to recover from this, you may use the `zfs_force` option or boot from a
+different filesystem and `zpool import -f` then `zpool export` the pool
+before rebooting with the new hostid.
+
+How it Works
+============
+
+The Dracut module consists of the following files (less Makefile's):
+
+* `module-setup.sh`: Script run by the initramfs builder to create the
+ramdisk.  Contains instructions on which files are required by the modules
+and z* programs.  Also triggers inclusion of `/etc/hostid` and the zpool
+cache.  This file is not included in the initramfs.
+
+* `90-zfs.rules`: udev rules which trigger loading of the ZFS modules at boot.
+
+* `parse-zfs.sh`: Run early in the initramfs boot process to parse kernel
+command line and determine if ZFS is the active root filesystem.
+
+* `mount-zfs.sh`: Run later in initramfs boot process after udev has settled
+to mount the root dataset.
+
+`module-setup.sh`
+---------------
+
+This file is run by the Dracut script within the live system, not at boot
+time.  It's not included in the final initramfs.  Functions in this script
+describe which files are needed by ZFS at boot time.
+
+Currently all the various z* and spl modules are included, a dependency is
+asserted on udev-rules, and the various zfs, zpool, etc. helpers are included.
+Dr</span><span class="stdout">acut provides library functions which automatically gather the shared libs
+necessary to run each of these binaries, so statically built binaries are
+not required.
+
+The zpool and zvol udev rules files are copied from where they are
+installed by the ZFS build.  __PACKAGERS TAKE NOTE__: If you move
+`/etc/udev/rules/60-z*.rules`, you'll need to update this file to match.
+
+Currently this file also includes `/etc/hostid` and `/etc/zfs/zpool.cache`
+which means the generated ramdisk is specific to the host system which built
+it.  If a generic initramfs is required, it may be preferable to omit these
+files and specify the `spl_hostid` from the boot loader instead.
+
+`parse-zfs.sh`
+------------
+
+Run during the cmdline phase of the initramfs boot process, this script
+performs some basic sanity checks on kernel command line parameters to
+determine if booting from ZFS is likely to be what is desired.  Dracut
+requires this script to adjust the `root` variable if required and to set
+`rootok=1` if a mountable root filesystem is available.  Unfortunately this
+script must run before udev is settled and kernel modules are known to be
+loaded, so accessing the zpool and zfs commands is unsafe.
+
+If the root=ZFS... parameter is set on the command line, then it's at least
+certain that ZFS is what is desired, though this script is unable to
+determine if ZFS is in fact available.  This script will alter the `root`
+parameter to replace several historical forms of specifying the pool and
+dataset name with the canonical form of `zfs:pool/dataset`.
+
+If no root= parameter is set, the best this script can do is guess that
+ZFS is desired.  At present, no other known filesystems will work with no
+root= parameter, though this might possibly interfere with using the
+compiled-in default root in the kernel image.  It's considered unlikely
+that would ever be the case when an initramfs is in use, so this script
+sets `root=zfs:AUTO` and hopes for the best.
+
+Once the root=... (or lack thereof) parameter is parsed, a dummy symlink
+is created from `/dev/root` -&gt; `/dev/null` to satisfy parts of the Dracut
+process which check for presence of a single root device node.
+
+Finally, an initqueue/finished hook is registered which causes the initqueue
+phase of Dracut to wait for `/dev/zfs` to become available before attempting
+to mount anything.
+
+`mount-zfs.sh`
+------------
+
+This script is run after udev has settled and all tasks in the initqueue
+have succeeded.  This ensures that `/dev/zfs` is available and that the
+various ZFS modules are successfully loaded.  As it is now safe to call
+zpool and friends, we can proceed to find the bootfs attribute if necessary.
+
+If the root parameter was explicitly set on the command line, no parsing is
+necessary.  The list of imported pools is checked to see if the desired pool
+is already imported.  If it's not, and attempt is made to import the pool
+explicitly, though no force is attempted.  Finally the specified dataset
+is mounted on `$NEWROOT`, first using the `-o zfsutil` option to handle
+non-legacy mounts, then if that fails, without zfsutil to handle legacy
+mount points.
+
+If no root parameter was specified, this script attempts to find a pool with
+its bootfs attribute set.  First, already-imported pools are scanned and if
+an appropriate pool is found, no additional pools are imported.  If no pool
+with bootfs is found, any additional pools in the system are imported with
+`zpool import -N -a`, and the scan for bootfs is tried again.  If no bootfs
+is found with all pools imported, all pools are re-exported, and boot fails.
+Assuming a bootfs is found, an attempt is made to mount it to `$NEWROOT`,
+first with, then without the zfsutil option as above.
+
+Ordinarily pools are imported _without_ the force option which may cause
+boot to fail if the hostid has changed or a pool has been physically moved
+between servers.  The `zfs_force` kernel parameter is provided which when
+set to `1` causes `zpool import` to be run with the `-f` flag.  Forcing pool
+import can lead to serious data corruption and loss of pools, so this option
+should be used with extreme caution.  Note that even with this flag set, if
+the required zpool was auto-imported by the kernel module, no additional
+`zpool import` commands are run, so nothing is forced.
diff --git a/etc/init.d/zfs.fedora b/etc/init.d/zfs.fedora
index bfed452..70b7281 100644
--- a/etc/init.d/zfs.fedora
+++ b/etc/init.d/zfs.fedora
@@ -158,6 +158,8 @@ start()
 	
 	action $&quot;Mounting ZFS filesystems not yet mounted: &quot; $ZFS mount -a || return 152
 
+	action $&quot;Exporting ZFS filesystems: &quot; $ZFS share -a || return 153
+
 	read_mtab  &quot;^/dev/zd&quot;
 	read_fstab &quot;^/dev/zd&quot;
 
diff --git a/etc/init.d/zfs.gentoo b/etc/init.d/zfs.gentoo
index a33d9dc..f709ed9 100644
--- a/etc/init.d/zfs.gentoo
+++ b/etc/init.d/zfs.gentoo
@@ -5,21 +5,19 @@
 
 depend()
 {
-	before net
-	after udev
+	# bootmisc will log to /var which may be a different zfs than root.
+	before net bootmisc
+	after udev localmount
 	keyword -lxc -openvz -prefix -vserver
 }
 
 CACHEFILE=/etc/zfs/zpool.cache
-ZPOOL=/usr/sbin/zpool
-ZFS=/usr/sbin/zfs
+ZPOOL=/sbin/zpool
+ZFS=/sbin/zfs
 ZFS_MODULE=zfs
 
 checksystem() {
-	if [ -c /dev/zfs ]; then
-		einfo &quot;ZFS modules already loaded&quot;
-		return 0
-	else
+	if [ ! -c /dev/zfs ]; then
 		einfo &quot;Checking if ZFS modules present&quot;
 		if [ &quot;x$(modprobe -l  $ZFS_MODULE | grep $ZFS_MODULE)&quot; == &quot;x&quot; ]; then
 			eerror &quot;$ZFS_MODULE not found. Is the ZFS package installed?&quot;
@@ -79,6 +77,15 @@ start() {
 		return $rv
 	fi
 
+	einfo &quot;Exporting ZFS filesystems&quot;
+	$ZFS share -a
+	rv=$?
+	if [ $rv -ne 0 ]; then
+		eerror &quot;Failed to export ZFS filesystems.&quot;
+		eend $rv
+		return $rv
+	fi
+
 	eend 0
 	return 0
 }
@@ -89,10 +96,12 @@ stop()
 	$ZFS umount -a
 	rv=$?
 	if [ $rv -ne 0 ]; then
-		eerror &quot;Failed to umount ZFS filesystems.&quot;
+		einfo &quot;Some ZFS filesystems not unmounted&quot;
 	fi
 
-	eend $rv
+	# Don't fail if we couldn't umount everything.  /usr might be in use.
+	eend 0
+	return 0
 }
 
 status()
diff --git a/etc/init.d/zfs.lsb b/etc/init.d/zfs.lsb
index 6c0a743..9cc6756 100644
--- a/etc/init.d/zfs.lsb
+++ b/etc/init.d/zfs.lsb
@@ -74,6 +74,10 @@ start()
 		log_begin_msg &quot;Mounting ZFS filesystems&quot;
 		$ZFS mount -a
 		log_end_msg $?
+
+		log_begin_msg &quot;Exporting ZFS filesystems&quot;
+		$ZFS share -a
+		log_end_msg $?
 	fi
 	
 	touch $LOCKFILE
diff --git a/etc/init.d/zfs.lunar b/etc/init.d/zfs.lunar
index 4512151..bdc461a 100644
--- a/etc/init.d/zfs.lunar
+++ b/etc/init.d/zfs.lunar
@@ -31,16 +31,24 @@ case $1 in
       # do, thus i'm not breaking here.
     fi
 
-     # mount the filesystems
-     while IFS= read -r -d $'\n' dev; do
-       mdev=$(echo &quot;$dev&quot; | awk '{ print $1; }')
-       echo -n &quot;mounting $mdev...&quot;
-       if `zfs mount $mdev`; then
-         echo -e &quot;done&quot;;
-       else
-         echo -e &quot;failed&quot;;
-       fi
-     done &lt; &lt;(zfs list -H);
+    # mount the filesystems
+    while IFS= read -r -d $'\n' dev; do
+      mdev=$(echo &quot;$dev&quot; | awk '{ print $1; }')
+      echo -n &quot;mounting $mdev...&quot;
+      if zfs mount $mdev; then
+        echo -e &quot;done&quot;;
+      else
+        echo -e &quot;failed&quot;;
+      fi
+    done &lt; &lt;(zfs list -H);
+
+    # export the filesystems
+    echo -n &quot;exporting ZFS filesystems...&quot;
+    if zfs share -a; then
+      echo -e &quot;done&quot;;
+    else
+      echo -e &quot;failed&quot;;
+    fi
 
 
   ;;
@@ -52,7 +60,7 @@ case $1 in
       while IFS= read -r -d $'\n' dev; do
         mdev=$(echo &quot;$dev&quot; | awk '{ print $1 }');
         echo -n &quot;umounting $mdev...&quot;;
-        if `zfs umount $mdev`; then
+        if zfs umount $mdev; then
           echo -e &quot;done&quot;;
         else
           echo -e &quot;failed&quot;;
diff --git a/etc/init.d/zfs.redhat b/etc/init.d/zfs.redhat
index 3f34f2f..c1f2fb8 100644
--- a/etc/init.d/zfs.redhat
+++ b/etc/init.d/zfs.redhat
@@ -87,6 +87,8 @@ start()
 
 	action $&quot;Mounting automounted ZFS filesystems: &quot; $ZFS mount -a || return 152
 
+	action $&quot;Exporting ZFS filesystems: &quot; $ZFS share -a || return 153
+
 	# Read fstab, try to mount zvols ignoring error
 	read_fstab &quot;^/dev/(zd|zvol)&quot;
 	template=$&quot;Mounting volume %s registered in fstab: &quot;
diff --git a/lib/Makefile.am b/lib/Makefile.am
index c0f3878..0d518d2 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -1 +1,2 @@
-SUBDIRS = libspl libavl libefi libnvpair libunicode libuutil libzpool libzfs
+SUBDIRS  = libspl libavl libefi libnvpair libshare
+SUBDIRS += libunicode libuutil libzpool libzfs
diff --git a/lib/Makefile.in b/lib/Makefile.in
index 107aa76..b5c4d87 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -301,7 +301,8 @@ target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-SUBDIRS = libspl libavl libefi libnvpair libunicode libuutil libzpool libzfs
+SUBDIRS = libspl libavl libefi libnvpair libshare libunicode libuutil \
+	libzpool libzfs
 all: all-recursive
 
 .SUFFIXES:
diff --git a/lib/libavl/Makefile.am b/lib/libavl/Makefile.am
index b06904f..3993920 100644
--- a/lib/libavl/Makefile.am
+++ b/lib/libavl/Makefile.am
@@ -10,3 +10,5 @@ lib_LTLIBRARIES = libavl.la
 
 libavl_la_SOURCES = \
 	$(top_srcdir)/module/avl/avl.c
+
+libavl_la_LDFLAGS = -version-info 1:0:0
diff --git a/lib/libavl/Makefile.in b/lib/libavl/Makefile.in
index f7a6abd..0a57d73 100644
--- a/lib/libavl/Makefile.in
+++ b/lib/libavl/Makefile.in
@@ -116,6 +116,9 @@ libavl_la_OBJECTS = $(am_libavl_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
 am__v_lt_0 = --silent
+libavl_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libavl_la_LDFLAGS) $(LDFLAGS) -o $@
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -326,6 +329,7 @@ lib_LTLIBRARIES = libavl.la
 libavl_la_SOURCES = \
 	$(top_srcdir)/module/avl/avl.c
 
+libavl_la_LDFLAGS = -version-info 1:0:0
 all: all-am</span><span class="stdout">
 
 .SUFFIXES:
@@ -392,7 +396,7 @@ clean-libLTLIBRARIES:
 	  rm -f &quot;$${dir}/so_locations&quot;; \
 	done
 libavl.la: $(libavl_la_OBJECTS) $(libavl_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) -rpath $(libdir) $(libavl_la_OBJECTS) $(libavl_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libavl_la_LINK) -rpath $(libdir) $(libavl_la_OBJECTS) $(libavl_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/lib/libefi/Makefile.am b/lib/libefi/Makefile.am
index 57f1bd3..cf9e3f1 100644
--- a/lib/libefi/Makefile.am
+++ b/lib/libefi/Makefile.am
@@ -10,3 +10,5 @@ lib_LTLIBRARIES = libefi.la
 
 libefi_la_SOURCES = \
 	$(top_srcdir)/lib/libefi/rdwr_efi.c
+
+libefi_la_LDFLAGS = -version-info 1:0:0
diff --git a/lib/libefi/Makefile.in b/lib/libefi/Makefile.in
index f2cb560..d6ec593 100644
--- a/lib/libefi/Makefile.in
+++ b/lib/libefi/Makefile.in
@@ -116,6 +116,9 @@ libefi_la_OBJECTS = $(am_libefi_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
 am__v_lt_0 = --silent
+libefi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libefi_la_LDFLAGS) $(LDFLAGS) -o $@
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -326,6 +329,7 @@ lib_LTLIBRARIES = libefi.la
 libefi_la_SOURCES = \
 	$(top_srcdir)/lib/libefi/rdwr_efi.c
 
+libefi_la_LDFLAGS = -version-info 1:0:0
 all: all-am
 
 .SUFFIXES:
@@ -392,7 +396,7 @@ clean-libLTLIBRARIES:
 	  rm -f &quot;$${dir}/so_locations&quot;; \
 	done
 libefi.la: $(libefi_la_OBJECTS) $(libefi_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) -rpath $(libdir) $(libefi_la_OBJECTS) $(libefi_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libefi_la_LINK) -rpath $(libdir) $(libefi_la_OBJECTS) $(libefi_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/lib/libnvpair/Makefile.am b/lib/libnvpair/Makefile.am
index 33edf3b..919e453 100644
--- a/lib/libnvpair/Makefile.am
+++ b/lib/libnvpair/Makefile.am
@@ -14,5 +14,7 @@ libnvpair_la_SOURCES = \
 	$(top_srcdir)/module/nvpair/nvpair_alloc_fixed.c \
 	$(top_srcdir)/module/nvpair/nvpair.c
 
+libnvpair_la_LDFLAGS = -version-info 1:0:0
+
 EXTRA_DIST = \
 	$(top_srcdir)/module/nvpair/nvpair_alloc_spl.c
diff --git a/lib/libnvpair/Makefile.in b/lib/libnvpair/Makefile.in
index 13e64b5..8e47551 100644
--- a/lib/libnvpair/Makefile.in
+++ b/lib/libnvpair/Makefile.in
@@ -117,6 +117,9 @@ libnvpair_la_OBJECTS = $(am_libnvpair_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
 am__v_lt_0 = --silent
+libnvpair_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libnvpair_la_LDFLAGS) $(LDFLAGS) -o $@
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -330,6 +333,7 @@ libnvpair_la_SOURCES = \
 	$(top_srcdir)/module/nvpair/nvpair_alloc_fixed.c \
 	$(top_srcdir)/module/nvpair/nvpair.c
 
+libnvpair_la_LDFLAGS = -version-info 1:0:0
 EXTRA_DIST = \
 	$(top_srcdir)/module/nvpair/nvpair_alloc_spl.c
 
@@ -399,7 +403,7 @@ clean-libLTLIBRARIES:
 	  rm -f &quot;$${dir}/so_locations&quot;; \
 	done
 libnvpair.la: $(libnvpair_la_OBJECTS) $(libnvpair_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) -rpath $(libdir) $(libnvpair_la_OBJECTS) $(libnvpair_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libnvpair_la_LINK) -rpath $(libdir) $(libnvpair_la_OBJECTS) $(libnvpair_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/lib/libshare/Makefile.am b/lib/libshare/Makefile.am
new file mode 100644
index 0000000..b66df8c
--- /dev/null
+++ b/lib/libshare/Makefile.am
@@ -0,0 +1,15 @@
+include $(top_srcdir)/config/Rules.am
+
+DEFAULT_INCLUDES += \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/lib/libspl/include
+
+lib_LTLIBRARIES = libshare.la
+
+libshare_la_SOURCES = \
+	$(top_srcdir)/lib/libshare/libshare.c \
+	$(top_srcdir)/lib/libshare/nfs.c \
+	$(top_srcdir)/lib/libshare/libshare_impl.h \
+	$(top_srcdir)/lib/libshare/nfs.h
+
+libshare_la_LDFLAGS = -version-info 1:0:0
diff --git a/lib/libshare/Makefile.in b/lib/libshare/Makefile.in
new file mode 100644
index 0000000..c0122cd
--- /dev/null
+++ b/lib/libshare/Makefile.in
@@ -0,0 +1,662 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/config/Rules.am
+subdir = lib/libshare
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
+	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
+	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
+	$(top_srcdir)/config/kernel-bio-empty-barrier.m4 \
+	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
+	$(top_srcdir)/config/kernel-bio-failfast.m4 \
+	$(top_srcdir)/config/kernel-bio-rw-syncio.m4 \
+	$(top_srcdir)/config/kernel-blk-end-request.m4 \
+	$(top_srcdir)/config/kernel-blk-fetch-request.m4 \
+	$(top_srcdir)/config/kernel-blk-requeue-request.m4 \
+	$(top_srcdir)/config/kernel-blk-rq-bytes.m4 \
+	$(top_srcdir)/config/kernel-blk-rq-pos.m4 \
+	$(top_srcdir)/config/kernel-blk-rq-sectors.m4 \
+	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
+	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
+	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
+	$(top_srcdir)/config/kernel-evict-inode.m4 \
+	$(top_srcdir)/config/kernel-fmode-t.m4 \
+	$(top_srcdir)/config/kernel-fsync.m4 \
+	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
+	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
+	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
+	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
+	$(top_srcdir)/config/kernel-mount-nodev.m4 \
+	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
+	$(top_srcdir)/config/kernel-rq-for-each_segment.m4 \
+	$(top_srcdir)/config/kernel-rq-is_sync.m4 \
+	$(top_srcdir)/config/kernel-security-inode-init.m4 \
+	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
+	$(top_srcdir)/config/kernel-xattr-handler.m4 \
+	$(top_srcdir)/config/kernel.m4 \
+	$(top_srcdir)/config/user-arch.m4 \
+	$(top_srcdir)/config/user-frame-larger-than.m4 \
+	$(top_srcdir)/config/user-ioctl.m4 \
+	$(top_srcdir)/config/user-libblkid.m4 \
+	$(top_srcdir)/config/user-libuuid.m4 \
+	$(top_srcdir)/config/user-nptl_guard_within_stack.m4 \
+	$(top_srcdir)/config/user-selinux.m4 \
+	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
+	$(top_srcdir)/config/zfs-build.m4 \
+	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/zfs_config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo &quot;$$p&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's/[].[^$$\\*|]/\\\\&amp;/g'`
+am__nobase_strip = \
+  for p in $$list; do echo &quot;$$p&quot;; done | sed -e &quot;s|$$srcdirstrip/||&quot;
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo &quot;$$p $$p&quot;; done | \
+  sed &quot;s| $$srcdirstrip/| |;&quot;' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files[&quot;.&quot;] = &quot;&quot; } { files[$$2] = files[$$2] &quot; &quot; $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = &quot;&quot; } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = &quot;$(DESTDIR)$(libdir)&quot;
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libshare_la_LIBADD =
+am_libshare_la_OBJECTS = libshare.lo nfs.lo
+libshare_la_OBJECTS = $(am_libshare_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+libshare_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libshare_la_LDFLAGS) $(LDFLAGS) -o $@
+depcomp = $(SHELL) $(top_srcdir)/config/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo &quot;  CC    &quot; $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DE</span><span class="stdout">FAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo &quot;  CCLD  &quot; $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo &quot;  GEN   &quot; $@;
+SOURCES = $(libshare_la_SOURCES)
+DIST_SOURCES = $(libshare_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALIEN = @ALIEN@
+ALIEN_VERSION = @ALIEN_VERSION@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEBUG_CFLAGS = @DEBUG_CFLAGS@
+DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
+DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
+DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DPKG = @DPKG@
+DPKGBUILD = @DPKGBUILD@
+DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
+DPKG_VERSION = @DPKG_VERSION@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
+GREP = @GREP@
+HAVE_ALIEN = @HAVE_ALIEN@
+HAVE_DPKG = @HAVE_DPKG@
+HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
+HAVE_RPM = @HAVE_RPM@
+HAVE_RPMBUILD = @HAVE_RPMBUILD@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KERNELCPPFLAGS = @KERNELCPPFLAGS@
+KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBBLKID = @LIBBLKID@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBSELINUX = @LIBSELINUX@
+LIBTOOL = @LIBTOOL@
+LIBUUID = @LIBUUID@
+LINUX = @LINUX@
+LINUX_OBJ = @LINUX_OBJ@
+LINUX_SYMBOLS = @LINUX_SYMBOLS@
+LINUX_VERSION = @LINUX_VERSION@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+RPM = @RPM@
+RPMBUILD = @RPMBUILD@
+RPMBUILD_VERSION = @RPMBUILD_VERSION@
+RPM_VERSION = @RPM_VERSION@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SPL = @SPL@
+SPL_OBJ = @SPL_OBJ@
+SPL_SYMBOLS = @SPL_SYMBOLS@
+SPL_VERSION = @SPL_VERSION@
+STRIP = @STRIP@
+TARGET_ASM_DIR = @TARGET_ASM_DIR@
+VENDOR = @VENDOR@
+VERSION = @VERSION@
+ZFS_CONFIG = @ZFS_CONFIG@
+ZFS_META_ALIAS = @ZFS_META_ALIAS@
+ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
+ZFS_META_DATA = @ZFS_META_DATA@
+ZFS_META_LICENSE = @ZFS_META_LICENSE@
+ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
+ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
+ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
+ZFS_META_NAME = @ZFS_META_NAME@
+ZFS_META_RELEASE = @ZFS_META_RELEASE@
+ZFS_META_VERSION = @ZFS_META_VERSION@
+ZLIB = @ZLIB@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+DEFAULT_INCLUDES = -include ${top_builddir}/zfs_config.h \
+	-I$(top_srcdir)/include -I$(top_srcdir)/lib/libspl/include
+AM_LIBTOOLFLAGS = --silent
+AM_CFLAGS = -Wall -Wstrict-prototypes -fno-strict-aliasing \
+	${NO_UNUSED_BUT_SET_VARIABLE} ${DEBUG_CFLAGS} -D_GNU_SOURCE \
+	-D__EXTENSIONS__ -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS \
+	-D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE \
+	-DTEXT_DOMAIN=\&quot;zfs-linux-user\&quot;
+lib_LTLIBRARIES = libshare.la
+libshare_la_SOURCES = \
+	$(top_srcdir)/lib/libshare/libshare.c \
+	$(top_srcdir)/lib/libshare/nfs.c \
+	$(top_srcdir)/lib/libshare/libshare_impl.h \
+	$(top_srcdir)/lib/libshare/nfs.h
+
+libshare_la_LDFLAGS = -version-info 1:0:0
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/config/Rules.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        &amp;&amp; { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) &amp;&amp; $(AUTOMAKE) --gnu lib/libshare/Makefile'; \
+	$(am__cd) $(top_srcdir) &amp;&amp; \
+	  $(AUTOMAKE) --gnu lib/libshare/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z &quot;$(libdir)&quot; || $(MKDIR_P) &quot;$(DESTDIR)$(libdir)&quot;
+	@list='$(lib_LTLIBRARIES)'; test -n &quot;$(libdir)&quot; || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2=&quot;$$list2 $$p&quot;; \
+	  else :; fi; \
+	done; \
+	test -z &quot;$$list2&quot; || { \
+	  echo &quot; $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'&quot;; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 &quot;$(DESTDIR)$(libdir)&quot;; \
+	}
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n &quot;$(libdir)&quot; || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo &quot; $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'&quot;; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f &quot;$(DESTDIR)$(libdir)/$$f&quot;; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z &quot;$(lib_LTLIBRARIES)&quot; || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir=&quot;`echo $$p | sed -e 's|/[^/]*$$||'`&quot;; \
+	  test &quot;$$dir&quot; != &quot;$$p&quot; || dir=.; \
+	  echo &quot;rm -f \&quot;$${dir}/so_locations\&quot;&quot;; \
+	  rm -f &quot;$${dir}/so_locations&quot;; \
+	done
+libshare.la: $(libshare_la_OBJECTS) $(libshare_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libshare_la_LINK) -rpath $(libdir) $(libshare_la_OBJECTS) $(libshare_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libshare.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nfs.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $&lt;
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $&lt;
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$&lt;'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$&lt;'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $&lt;
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@</span><span class="stdout">am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $&lt;
+
+libshare.lo: $(top_srcdir)/lib/libshare/libshare.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libshare.lo -MD -MP -MF $(DEPDIR)/libshare.Tpo -c -o libshare.lo `test -f '$(top_srcdir)/lib/libshare/libshare.c' || echo '$(srcdir)/'`$(top_srcdir)/lib/libshare/libshare.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libshare.Tpo $(DEPDIR)/libshare.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(top_srcdir)/lib/libshare/libshare.c' object='libshare.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libshare.lo `test -f '$(top_srcdir)/lib/libshare/libshare.c' || echo '$(srcdir)/'`$(top_srcdir)/lib/libshare/libshare.c
+
+nfs.lo: $(top_srcdir)/lib/libshare/nfs.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT nfs.lo -MD -MP -MF $(DEPDIR)/nfs.Tpo -c -o nfs.lo `test -f '$(top_srcdir)/lib/libshare/nfs.c' || echo '$(srcdir)/'`$(top_srcdir)/lib/libshare/nfs.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/nfs.Tpo $(DEPDIR)/nfs.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(top_srcdir)/lib/libshare/nfs.c' object='nfs.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o nfs.lo `test -f '$(top_srcdir)/lib/libshare/nfs.c' || echo '$(srcdir)/'`$(top_srcdir)/lib/libshare/nfs.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z &quot;$(ETAGS_ARGS)$$*$$unique&quot;; then :; else \
+	  test -n &quot;$$unique&quot; || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      &quot;$$@&quot; $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z &quot;$(CTAGS_ARGS)$$unique&quot; \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) &amp;&amp; pwd` \
+	  &amp;&amp; $(am__cd) $(top_srcdir) \
+	  &amp;&amp; gtags -i $(GTAGS_ARGS) &quot;$$here&quot;
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's/[].[^$$\\*]/\\\\&amp;/g'`; \
+	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's/[].[^$$\\*]/\\\\&amp;/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e &quot;s|^$$srcdirstrip/||;t&quot; \
+	      -e &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|;t&quot;`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo &quot;$$dist_files&quot; | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo &quot;/$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d &quot;$(distdir)/$$file&quot;; then \
+	      find &quot;$(distdir)/$$file&quot; -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file &quot;$(distdir)$$dir&quot; || exit 1; \
+	      find &quot;$(distdir)/$$file&quot; -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file &quot;$(distdir)$$dir&quot; || exit 1; \
+	  else \
+	    test -f &quot;$(distdir)/$$file&quot; \
+	    || cp -p $$d/$$file &quot;$(distdir)/$$file&quot; \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in &quot;$(DESTDIR)$(libdir)&quot;; do \
+	  test -z &quot;$$dir&quot; || $(MKDIR_P) &quot;$$dir&quot;; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
+	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z &quot;$(CONFIG_CLEAN_FILES)&quot; || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = &quot;$(srcdir)&quot; || test -z &quot;$(CONFIG_CLEAN_VPATH_FILES)&quot; || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo &quot;This command is intended for maintainers to use&quot;
+	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/lib/libshare/libshare.c b/lib/libshare/libshare.c
new file mode 100644
index 0000000..c34e839
--- /dev/null
+++ b/lib/libshare/libshare.c
@@ -0,0 +1,810 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the &quot;License&quot;).
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011 Gunnar Beutner
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;strings.h&gt;
+#include &lt;libintl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;libzfs.h&gt;
+#include &lt;libshare.h&gt;
+#include &quot;libshare_impl.h&quot;
+#include &quot;nfs.h&quot;
+
+static sa_share_impl_t find_share(sa_handle_impl_t handle,
+    const char *sharepath);
+static sa_share_impl_t alloc_share(const char *sharepa</span><span class="stdout">th);
+static void free_share(sa_share_impl_t share);
+
+static void parse_sharetab(sa_handle_impl_t impl_handle);
+static int process_share(sa_handle_impl_t impl_handle,
+    sa_share_impl_t impl_share, char *pathname, char *resource,
+    char *fstype, char *options, char *description,
+    char *dataset, boolean_t from_sharetab);
+static void update_sharetab(sa_handle_impl_t impl_handle);
+
+static int update_zfs_share(sa_share_impl_t impl_handle, const char *proto);
+static int update_zfs_shares(sa_handle_impl_t impl_handle, const char *proto);
+
+static int fstypes_count;
+static sa_fstype_t *fstypes;
+
+sa_fstype_t *
+register_fstype(const char *name, const sa_share_ops_t *ops)
+{
+	sa_fstype_t *fstype;
+
+	fstype = calloc(sizeof (sa_fstype_t), 1);
+
+	if (fstype == NULL)
+		return NULL;
+
+	fstype-&gt;name = name;
+	fstype-&gt;ops = ops;
+	fstype-&gt;fsinfo_index = fstypes_count;
+
+	fstypes_count++;
+
+	fstype-&gt;next = fstypes;
+	fstypes = fstype;
+
+	return fstype;
+}
+
+sa_handle_t
+sa_init(int init_service)
+{
+	sa_handle_impl_t impl_handle;
+
+	impl_handle = calloc(sizeof (struct sa_handle_impl), 1);
+
+	if (impl_handle == NULL)
+		return NULL;
+
+	impl_handle-&gt;zfs_libhandle = libzfs_init();
+
+	if (impl_handle-&gt;zfs_libhandle != NULL) {
+		libzfs_print_on_error(impl_handle-&gt;zfs_libhandle, B_TRUE);
+	}
+
+	parse_sharetab(impl_handle);
+	update_zfs_shares(impl_handle, NULL);
+
+	return ((sa_handle_t)impl_handle);
+}
+
+__attribute__((constructor)) static void
+libshare_init(void)
+{
+	libshare_nfs_init();
+
+	/*
+	 * This bit causes /etc/dfs/sharetab to be updated before libzfs gets a
+	 * chance to read that file; this is necessary because the sharetab file
+	 * might be out of sync with the NFS kernel exports (e.g. due to reboots
+	 * or users manually removing shares)
+	 */
+	sa_fini(sa_init(0));
+}
+
+static void
+parse_sharetab(sa_handle_impl_t impl_handle) {
+	FILE *fp;
+	char line[512];
+	char *eol, *pathname, *resource, *fstype, *options, *description;
+
+	fp = fopen(&quot;/etc/dfs/sharetab&quot;, &quot;r&quot;);
+
+	if (fp == NULL)
+		return;
+
+	while (fgets(line, sizeof (line), fp) != NULL) {
+		eol = line + strlen(line) - 1;
+
+		while (eol &gt;= line) {
+			if (*eol != '\r' &amp;&amp; *eol != '\n')
+				break;
+
+			*eol = '\0';
+			eol--;
+		}
+
+		pathname = line;
+
+		if ((resource = strchr(pathname, '\t')) == NULL)
+			continue;
+
+		*resource = '\0';
+		resource++;
+
+		if ((fstype = strchr(resource, '\t')) == NULL)
+			continue;
+
+		*fstype = '\0';
+		fstype++;
+
+		if ((options = strchr(fstype, '\t')) == NULL)
+			continue;
+
+		*options = '\0';
+		options++;
+
+		if ((description = strchr(fstype, '\t')) != NULL) {
+			*description = '\0';
+			description++;
+		}
+
+		if (strcmp(resource, &quot;-&quot;) == 0)
+			resource = NULL;
+
+		(void) process_share(impl_handle, NULL, pathname, resource,
+		    fstype, options, description, NULL, B_TRUE);
+	}
+
+	fclose(fp);
+}
+
+static void
+update_sharetab(sa_handle_impl_t impl_handle)
+{
+	sa_share_impl_t impl_share;
+	int temp_fd;
+	FILE *temp_fp;
+	char tempfile[] = &quot;/etc/dfs/sharetab.XXXXXX&quot;;
+	sa_fstype_t *fstype;
+	const char *resource;
+
+	if (mkdir(&quot;/etc/dfs&quot;, 0755) &lt; 0 &amp;&amp; errno != EEXIST) {
+		return;
+	}
+
+	temp_fd = mkstemp(tempfile);
+
+	if (temp_fd &lt; 0)
+		return;
+
+	temp_fp = fdopen(temp_fd, &quot;w&quot;);
+
+	if (temp_fp == NULL)
+		return;
+
+	impl_share = impl_handle-&gt;shares;
+	while (impl_share != NULL) {
+		fstype = fstypes;
+		while (fstype != NULL) {
+			if (FSINFO(impl_share, fstype)-&gt;active &amp;&amp;
+			    FSINFO(impl_share, fstype)-&gt;shareopts != NULL) {
+				resource = FSINFO(impl_share, fstype)-&gt;resource;
+
+				if (resource == NULL)
+					resource = &quot;-&quot;;
+
+				fprintf(temp_fp, &quot;%s\t%s\t%s\t%s\n&quot;,
+				    impl_share-&gt;sharepath, resource,
+				    fstype-&gt;name,
+				    FSINFO(impl_share, fstype)-&gt;shareopts);
+			}
+
+			fstype = fstype-&gt;next;
+		}
+
+		impl_share = impl_share-&gt;next;
+	}
+
+	fflush(temp_fp);
+	fsync(temp_fd);
+	fclose(temp_fp);
+
+	rename(tempfile, &quot;/etc/dfs/sharetab&quot;);
+}
+
+typedef struct update_cookie_s {
+	sa_handle_impl_t handle;
+	const char *proto;
+} update_cookie_t;
+
+static int
+update_zfs_shares_cb(zfs_handle_t *zhp, void *pcookie)
+{
+	update_cookie_t *udata = (update_cookie_t *)pcookie;
+	char mountpoint[ZFS_MAXPROPLEN];
+	char shareopts[ZFS_MAXPROPLEN];
+	char *dataset;
+	zfs_type_t type = zfs_get_type(zhp);
+
+	if (type == ZFS_TYPE_FILESYSTEM &amp;&amp;
+	    zfs_iter_filesystems(zhp, update_zfs_shares_cb, pcookie) != 0) {
+		zfs_close(zhp);
+		return 1;
+	}
+
+	if (type != ZFS_TYPE_FILESYSTEM) {
+		zfs_close(zhp);
+		return 0;
+	}
+
+	if (zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,
+	    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) != 0) {
+		zfs_close(zhp);
+		return 0;
+	}
+
+	dataset = (char *)zfs_get_name(zhp);
+
+	if (dataset == NULL) {
+		zfs_close(zhp);
+		return 0;
+	}
+
+	if (!zfs_is_mounted(zhp, NULL)) {
+		zfs_close(zhp);
+		return 0;
+	}
+
+	if ((udata-&gt;proto == NULL || strcmp(udata-&gt;proto, &quot;nfs&quot;) == 0) &amp;&amp;
+	    zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,
+	    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &amp;&amp;
+	    strcmp(shareopts, &quot;off&quot;) != 0) {
+		(void) process_share(udata-&gt;handle, NULL, mountpoint, NULL,
+		    &quot;nfs&quot;, shareopts, NULL, dataset, B_FALSE);
+	}
+
+	if ((udata-&gt;proto == NULL || strcmp(udata-&gt;proto, &quot;smb&quot;) == 0) &amp;&amp;
+	    zfs_prop_get(zhp, ZFS_PROP_SHARESMB, shareopts,
+	    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &amp;&amp;
+	    strcmp(shareopts, &quot;off&quot;) != 0) {
+		(void) process_share(udata-&gt;handle, NULL, mountpoint, NULL,
+		    &quot;smb&quot;, shareopts, NULL, dataset, B_FALSE);
+	}
+
+	zfs_close(zhp);
+
+	return 0;
+}
+
+static int
+update_zfs_share(sa_share_impl_t impl_share, const char *proto)
+{
+	sa_handle_impl_t impl_handle = impl_share-&gt;handle;
+	zfs_handle_t *zhp;
+	update_cookie_t udata;
+
+	if (impl_handle-&gt;zfs_libhandle == NULL)
+			return SA_SYSTEM_ERR;
+
+	assert(impl_share-&gt;dataset != NULL);
+
+	zhp = zfs_open(impl_share-&gt;handle-&gt;zfs_libhandle, impl_share-&gt;dataset,
+	    ZFS_TYPE_FILESYSTEM);
+
+	if (zhp == NULL)
+		return SA_SYSTEM_ERR;
+
+	udata.handle = impl_handle;
+	udata.proto = proto;
+	(void) update_zfs_shares_cb(zhp, &amp;udata);
+
+	return SA_OK;
+}
+
+static int
+update_zfs_shares(sa_handle_impl_t impl_handle, const char *proto)
+{
+	update_cookie_t udata;
+
+	if (impl_handle-&gt;zfs_libhandle == NULL)
+		return SA_SYSTEM_ERR;
+
+	udata.handle = impl_handle;
+	udata.proto = proto;
+	(void) zfs_iter_root(impl_handle-&gt;zfs_libhandle, update_zfs_shares_cb,
+	    &amp;udata);
+
+	return SA_OK;
+}
+
+static int
+process_share(sa_handle_impl_t impl_handle, sa_share_impl_t impl_share,
+    char *pathname, char *resource, char *proto,
+    char *options, char *description, char *dataset,
+    boolean_t from_sharetab)
+{
+	struct stat statbuf;
+	int rc;
+	char *resource_dup = NULL, *dataset_dup = NULL;
+	boolean_t new_share;
+	sa_fstype_t *fstype;
+
+	new_share = B_FALSE;
+
+	if (impl_share == NULL)
+		impl_share = find_share(impl_handle, pathname);
+
+	if (impl_share == NULL) {
+		if (lstat(pathname, &amp;statbuf) != 0 ||
+		    !S_ISDIR(statbuf.st_mode))
+			return SA_BAD_PATH;
+
+		impl_share = alloc_share(pathname);
+
+		if (impl_share == NULL) {
+			rc = SA_NO_MEMORY;
+			goto err;
+		}
+
+		new_share = B_TRUE;
+	}
+
+	if (dataset != NULL) {
+		dataset_dup = strdup(dataset);
+
+		if (dataset_dup == NULL) {
+			rc = SA_NO_MEMORY;
+			goto err;
+		}
+	}
+
+	free(impl_share-&gt;dataset);
+	impl_share-&gt;dataset = dataset_dup;
+
+	rc = SA_INVALID_PROTOCOL;
+
+	fstype = fstypes;
+	while (fstype != NULL) {
+		if (strcmp(fstype-&gt;name, proto) == 0) {
+			if (resource != NULL) {
+				resource_dup = strdup(resource);
+
+				if (resource_dup == NULL) {
+					rc = SA_NO_MEMORY;
+					goto err;
+				}
+			}
+
+			free(FSINFO(impl_share, fstype)-&gt;resource);
+			FSINFO(impl_share, fstype)-&gt;resource = resource_dup;
+
+			rc = fstype-&gt;ops-&gt;update_shareopts(impl_share,
+			    resource, options);
+
+			if (rc == SA_OK &amp;&amp; from_sharetab)
+				FSINFO(impl_share, fstype)-&gt;active = B_TRUE;
+
+			break;
+		}
+
+		fstype = fstype-&gt;next;
+	}
+
+	if (rc != SA_OK)
+		goto err;
+
+	if (new_share) {
+		impl_share-&gt;handle = impl_handle;
+
+		impl_share-&gt;next = impl_handle-&gt;shares;
+		impl_handle-&gt;shares = impl_share;
+
+	}
+
+err:
+	if (rc != SA_OK) {
+		if (new_share)
+			free_share(impl_share);
+	}
+
+	return rc;
+}
+
+void
+sa_fini(sa_handle_t handle)
+{
+	sa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;
+	sa_share_impl_t impl_share, next;
+	sa_share_impl_t *pcurr;
+
+	if (impl_handle == NULL)
+		return;
+
+	/*
+	 * clean up shares which don't have a non-NULL dataset property,
+	 * which means they're in sharetab but we couldn't find their
+	 * ZFS dataset.
+	 */
+	pcurr = &amp;(impl_handle-&gt;shares);
+	impl_share = *pcurr;
+	while (impl_share != NULL) {
+		next = impl_share-&gt;next;
+
+		if (impl_share-&gt;dataset == NULL) {
+			/* remove item from the linked list */
+			*pcurr = next;
+
+			sa_disable_share(impl_share, NULL);
+
+			free_share(impl_share);
+		} else {
+			pcurr = &amp;(impl_share-&gt;next);
+		}
+
+		impl_share = next;
+	}
+
+	update_sharetab(impl_handle);
+
+	if (impl_handle-&gt;zfs_libhandle != NULL)
+		libzfs_fini(impl_handle-&gt;zfs_libhandle);
+
+	impl_share = impl_handle-&gt;shares;
+	while (impl_share != NULL) {
+		next = impl_share-&gt;next;
+		free_share(impl_share);
+		impl_share = next;
+	}
+
+	free(impl_handle);
+}
+
+static sa_share_impl_t
+find_share(sa_handle_impl_t impl_handle, const char *sharepath)
+{
+	sa_share_impl_t impl_share;
+
+	impl_share = impl_handle-&gt;shares;
+	while (impl_share != NULL) {
+		if (strcmp(impl_share-&gt;sharepath, sharepath) == 0) {
+			break;
+		}
+
+		impl_share = impl_share-&gt;next;
+	}
+
+	return impl_share;
+}
+
+sa_share_t
+sa_find_share(sa_handle_t handle, char *sharepath)
+{
+	return (sa_share_t)find_share((sa_handle_impl_t)handle, sharepath);
+}
+
+int
+sa_enable_share(sa_share_t share, char *protocol)
+{
+	sa_share_impl_t impl_share = (sa_share_impl_t)share;
+	int rc, ret;
+	boolean_t found_proto</span><span class="stdout">col;
+	sa_fstype_t *fstype;
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;sa_enable_share: share-&gt;sharepath=%s, protocol=%s\n&quot;,
+		impl_share-&gt;sharepath, protocol);
+#endif
+
+	assert(impl_share-&gt;handle != NULL);
+
+	ret = SA_OK;
+	found_protocol = B_FALSE;
+
+	fstype = fstypes;
+	while (fstype != NULL) {
+		if (protocol == NULL || strcmp(fstype-&gt;name, protocol) == 0) {
+			update_zfs_share(impl_share, fstype-&gt;name);
+
+			rc = fstype-&gt;ops-&gt;enable_share(impl_share);
+
+			if (rc != SA_OK)
+				ret = rc;
+			else
+				FSINFO(impl_share, fstype)-&gt;active = B_TRUE;
+
+			found_protocol = B_TRUE;
+		}
+
+		fstype = fstype-&gt;next;
+	}
+
+	update_sharetab(impl_share-&gt;handle);
+
+	return (found_protocol ? ret : SA_INVALID_PROTOCOL);
+}
+
+int
+sa_disable_share(sa_share_t share, char *protocol)
+{
+	sa_share_impl_t impl_share = (sa_share_impl_t)share;
+	int rc, ret;
+	boolean_t found_protocol;
+	sa_fstype_t *fstype;
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;sa_disable_share: share-&gt;sharepath=%s, protocol=%s\n&quot;,
+		impl_share-&gt;sharepath, protocol);
+#endif
+
+	ret = SA_OK;
+	found_protocol = B_FALSE;
+
+	fstype = fstypes;
+	while (fstype != NULL) {
+		if (protocol == NULL || strcmp(fstype-&gt;name, protocol) == 0) {
+			rc = fstype-&gt;ops-&gt;disable_share(impl_share);
+
+			if (rc == SA_OK) {
+				fstype-&gt;ops-&gt;clear_shareopts(impl_share);
+
+				FSINFO(impl_share, fstype)-&gt;active = B_FALSE;
+			} else
+				ret = rc;
+
+			found_protocol = B_TRUE;
+		}
+
+		fstype = fstype-&gt;next;
+	}
+
+	update_sharetab(impl_share-&gt;handle);
+
+	return (found_protocol ? ret : SA_INVALID_PROTOCOL);
+}
+
+/*
+ * sa_errorstr(err)
+ *
+ * convert an error value to an error string
+ */
+char *
+sa_errorstr(int err)
+{
+	static char errstr[32];
+	char *ret = NULL;
+
+	switch (err) {
+	case SA_OK:
+		ret = dgettext(TEXT_DOMAIN, &quot;ok&quot;);
+		break;
+	case SA_NO_SUCH_PATH:
+		ret = dgettext(TEXT_DOMAIN, &quot;path doesn't exist&quot;);
+		break;
+	case SA_NO_MEMORY:
+		ret = dgettext(TEXT_DOMAIN, &quot;no memory&quot;);
+		break;
+	case SA_DUPLICATE_NAME:
+		ret = dgettext(TEXT_DOMAIN, &quot;name in use&quot;);
+		break;
+	case SA_BAD_PATH:
+		ret = dgettext(TEXT_DOMAIN, &quot;bad path&quot;);
+		break;
+	case SA_NO_SUCH_GROUP:
+		ret = dgettext(TEXT_DOMAIN, &quot;no such group&quot;);
+		break;
+	case SA_CONFIG_ERR:
+		ret = dgettext(TEXT_DOMAIN, &quot;configuration error&quot;);
+		break;
+	case SA_SYSTEM_ERR:
+		ret = dgettext(TEXT_DOMAIN, &quot;system error&quot;);
+		break;
+	case SA_SYNTAX_ERR:
+		ret = dgettext(TEXT_DOMAIN, &quot;syntax error&quot;);
+		break;
+	case SA_NO_PERMISSION:
+		ret = dgettext(TEXT_DOMAIN, &quot;no permission&quot;);
+		break;
+	case SA_BUSY:
+		ret = dgettext(TEXT_DOMAIN, &quot;busy&quot;);
+		break;
+	case SA_NO_SUCH_PROP:
+		ret = dgettext(TEXT_DOMAIN, &quot;no such property&quot;);
+		break;
+	case SA_INVALID_NAME:
+		ret = dgettext(TEXT_DOMAIN, &quot;invalid name&quot;);
+		break;
+	case SA_INVALID_PROTOCOL:
+		ret = dgettext(TEXT_DOMAIN, &quot;invalid protocol&quot;);
+		break;
+	case SA_NOT_ALLOWED:
+		ret = dgettext(TEXT_DOMAIN, &quot;operation not allowed&quot;);
+		break;
+	case SA_BAD_VALUE:
+		ret = dgettext(TEXT_DOMAIN, &quot;bad property value&quot;);
+		break;
+	case SA_INVALID_SECURITY:
+		ret = dgettext(TEXT_DOMAIN, &quot;invalid security type&quot;);
+		break;
+	case SA_NO_SUCH_SECURITY:
+		ret = dgettext(TEXT_DOMAIN, &quot;security type not found&quot;);
+		break;
+	case SA_VALUE_CONFLICT:
+		ret = dgettext(TEXT_DOMAIN, &quot;property value conflict&quot;);
+		break;
+	case SA_NOT_IMPLEMENTED:
+		ret = dgettext(TEXT_DOMAIN, &quot;not implemented&quot;);
+		break;
+	case SA_INVALID_PATH:
+		ret = dgettext(TEXT_DOMAIN, &quot;invalid path&quot;);
+		break;
+	case SA_NOT_SUPPORTED:
+		ret = dgettext(TEXT_DOMAIN, &quot;operation not supported&quot;);
+		break;
+	case SA_PROP_SHARE_ONLY:
+		ret = dgettext(TEXT_DOMAIN, &quot;property not valid for group&quot;);
+		break;
+	case SA_NOT_SHARED:
+		ret = dgettext(TEXT_DOMAIN, &quot;not shared&quot;);
+		break;
+	case SA_NO_SUCH_RESOURCE:
+		ret = dgettext(TEXT_DOMAIN, &quot;no such resource&quot;);
+		break;
+	case SA_RESOURCE_REQUIRED:
+		ret = dgettext(TEXT_DOMAIN, &quot;resource name required&quot;);
+		break;
+	case SA_MULTIPLE_ERROR:
+		ret = dgettext(TEXT_DOMAIN, &quot;errors from multiple protocols&quot;);
+		break;
+	case SA_PATH_IS_SUBDIR:
+		ret = dgettext(TEXT_DOMAIN, &quot;path is a subpath of share&quot;);
+		break;
+	case SA_PATH_IS_PARENTDIR:
+		ret = dgettext(TEXT_DOMAIN, &quot;path is parent of a share&quot;);
+		break;
+	case SA_NO_SECTION:
+		ret = dgettext(TEXT_DOMAIN, &quot;protocol requires a section&quot;);
+		break;
+	case SA_NO_PROPERTIES:
+		ret = dgettext(TEXT_DOMAIN, &quot;properties not found&quot;);
+		break;
+	case SA_NO_SUCH_SECTION:
+		ret = dgettext(TEXT_DOMAIN, &quot;section not found&quot;);
+		break;
+	case SA_PASSWORD_ENC:
+		ret = dgettext(TEXT_DOMAIN, &quot;passwords must be encrypted&quot;);
+		break;
+	case SA_SHARE_EXISTS:
+		ret = dgettext(TEXT_DOMAIN, &quot;path or file is already shared&quot;);
+		break;
+	default:
+		(void) snprintf(errstr, sizeof (errstr),
+		    dgettext(TEXT_DOMAIN, &quot;unknown %d&quot;), err);
+		ret = errstr;
+	}
+	return (ret);
+}
+
+int
+sa_parse_legacy_options(sa_group_t group, char *options, char *proto)
+{
+	sa_fstype_t *fstype;
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;sa_parse_legacy_options: options=%s, proto=%s\n&quot;,
+		options, proto);
+#endif
+
+	fstype = fstypes;
+	while (fstype != NULL) {
+		if (strcmp(fstype-&gt;name, proto) != 0) {
+			fstype = fstype-&gt;next;
+			continue;
+		}
+
+		return fstype-&gt;ops-&gt;validate_shareopts(options);
+	}
+
+	return SA_INVALID_PROTOCOL;
+}
+
+boolean_t
+sa_needs_refresh(sa_handle_t handle)
+{
+	return B_TRUE;
+}
+
+libzfs_handle_t *
+sa_get_zfs_handle(sa_handle_t handle)
+{
+	sa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;
+
+	if (impl_handle == NULL)
+		return NULL;
+
+	return impl_handle-&gt;zfs_libhandle;
+}
+
+static sa_share_impl_t
+alloc_share(const char *sharepath)
+{
+	sa_share_impl_t impl_share;
+
+	impl_share = calloc(sizeof (struct sa_share_impl), 1);
+
+	if (impl_share == NULL)
+		return NULL;
+
+	impl_share-&gt;sharepath = strdup(sharepath);
+
+	if (impl_share-&gt;sharepath == NULL) {
+		free(impl_share);
+		return NULL;
+	}
+
+	impl_share-&gt;fsinfo = calloc(sizeof (sa_share_fsinfo_t), fstypes_count);
+
+	if (impl_share-&gt;fsinfo == NULL) {
+		free(impl_share-&gt;sharepath);
+		free(impl_share);
+		return NULL;
+	}
+
+	return impl_share;
+}
+
+static void
+free_share(sa_share_impl_t impl_share) {
+	sa_fstype_t *fstype;
+
+	fstype = fstypes;
+	while (fstype != NULL) {
+		fstype-&gt;ops-&gt;clear_shareopts(impl_share);
+
+		free(FSINFO(impl_share, fstype)-&gt;resource);
+
+		fstype = fstype-&gt;next;
+	}
+
+	free(impl_share-&gt;sharepath);
+	free(impl_share-&gt;dataset);
+	free(impl_share-&gt;fsinfo);
+	free(impl_share);
+}
+
+int
+sa_zfs_process_share(sa_handle_t handle, sa_group_t group, sa_share_t share,
+    char *mountpoint, char *proto, zprop_source_t source, char *shareopts,
+    char *sourcestr, char *dataset)
+{
+	sa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;
+	sa_share_impl_t impl_share = (sa_share_impl_t)share;
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;sa_zfs_process_share: mountpoint=%s, proto=%s, &quot;
+	    &quot;shareopts=%s, sourcestr=%s, dataset=%s\n&quot;, mountpoint, proto,
+	    shareopts, sourcestr, dataset);
+#endif
+
+	return process_share(impl_handle, impl_share, mountpoint, NULL,
+	    proto, shareopts, NULL, dataset, B_FALSE);
+}
+
+void
+sa_update_sharetab_ts(sa_handle_t handle)
+{
+	sa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;
+
+	update_sharetab(impl_handle);
+}
diff --git a/lib/libshare/libshare_impl.h b/lib/libshare/libshare_impl.h
new file mode 100644
index 0000000..dfcec2f
--- /dev/null
+++ b/lib/libshare/libshare_impl.h
@@ -0,0 +1,70 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the &quot;License&quot;).
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011 Gunnar Beutner
+ */
+
+struct sa_handle_impl;
+
+typedef struct sa_share_fsinfo {
+	boolean_t active;
+	char *resource;
+	char *shareopts;
+} sa_share_fsinfo_t;
+
+typedef struct sa_share_impl {
+	struct sa_share_impl *next;
+
+	struct sa_handle_impl *handle;
+
+	char *sharepath;
+	char *dataset;
+
+	sa_share_fsinfo_t *fsinfo; /* per-fstype information */
+} *sa_share_impl_t;
+
+#define FSINFO(impl_share, fstype) (&amp;(impl_share-&gt;fsinfo[fstype-&gt;fsinfo_index]))
+
+typedef struct sa_share_ops {
+	int (*enable_share)(sa_share_impl_t share);
+	int (*disable_share)(sa_share_impl_t share);
+	int (*validate_shareopts)(const char *shareopts);
+	int (*update_shareopts)(sa_share_impl_t impl_share,
+	    const char *resource, const char *shareopts);
+	void (*clear_shareopts)(sa_share_impl_t impl_share);
+} sa_share_ops_t;
+
+typedef struct sa_fstype {
+	struct sa_fstype *next;
+
+	const char *name;
+	const sa_share_ops_t *ops;
+	int fsinfo_index;
+} sa_fstype_t;
+
+typedef struct sa_handle_impl {
+	libzfs_handle_t *zfs_libhandle;
+	sa_share_impl_t shares;
+} *sa_handle_impl_t;
+
+sa_fstype_t *register_fstype(const char *name, const sa_share_ops_t *ops);
diff --git a/lib/libshare/nfs.c b/lib/libshare/nfs.c
new file mode 100644
index 0000000..60edaa2
--- /dev/null
+++ b/lib/libshare/nfs.c
@@ -0,0 +1,705 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the &quot;License&quot;).
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obta</span><span class="stdout">in a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011 Gunnar Beutner
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;strings.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/wait.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;libzfs.h&gt;
+#include &lt;libshare.h&gt;
+#include &quot;libshare_impl.h&quot;
+
+static sa_fstype_t *nfs_fstype;
+static boolean_t nfs_available;
+
+typedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,
+    void *cookie);
+
+typedef int (*nfs_host_callback_t)(const char *sharepath, const char *host,
+    const char *security, const char *access, void *cookie);
+
+static int
+foreach_nfs_shareopt(const char *shareopts,
+    nfs_shareopt_callback_t callback, void *cookie)
+{
+	char *shareopts_dup, *opt, *cur, *value;
+	int was_nul, rc;
+
+	if (shareopts == NULL)
+		return SA_OK;
+
+	shareopts_dup = strdup(shareopts);
+
+	if (shareopts_dup == NULL)
+		return SA_NO_MEMORY;
+
+	opt = shareopts_dup;
+	was_nul = 0;
+
+	while (1) {
+		cur = opt;
+
+		while (*cur != ',' &amp;&amp; *cur != '\0')
+			cur++;
+
+		if (*cur == '\0')
+			was_nul = 1;
+
+		*cur = '\0';
+
+		if (cur &gt; opt) {
+			value = strchr(opt, '=');
+
+			if (value != NULL) {
+				*value = '\0';
+				value++;
+			}
+
+			rc = callback(opt, value, cookie);
+
+			if (rc != SA_OK) {
+				free(shareopts_dup);
+				return rc;
+			}
+		}
+
+		opt = cur + 1;
+
+		if (was_nul)
+			break;
+	}
+
+	free(shareopts_dup);
+
+	return 0;
+}
+
+typedef struct nfs_host_cookie_s {
+	nfs_host_callback_t callback;
+	const char *sharepath;
+	void *cookie;
+	const char *security;
+} nfs_host_cookie_t;
+
+static int
+foreach_nfs_host_cb(const char *opt, const char *value, void *pcookie)
+{
+	int rc;
+	const char *access;
+	char *host_dup, *host, *next;
+	nfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;foreach_nfs_host_cb: key=%s, value=%s\n&quot;, opt, value);
+#endif
+
+	if (strcmp(opt, &quot;sec&quot;) == 0)
+		udata-&gt;security = value;
+
+	if (strcmp(opt, &quot;rw&quot;) == 0 || strcmp(opt, &quot;ro&quot;) == 0) {
+		if (value == NULL)
+			value = &quot;*&quot;;
+
+		access = opt;
+
+		host_dup = strdup(value);
+
+		if (host_dup == NULL)
+			return SA_NO_MEMORY;
+
+		host = host_dup;
+
+		do {
+			next = strchr(host, ':');
+			if (next != NULL) {
+				*next = '\0';
+				next++;
+			}
+
+			rc = udata-&gt;callback(udata-&gt;sharepath, host,
+			    udata-&gt;security, access, udata-&gt;cookie);
+
+			if (rc != SA_OK) {
+				free(host_dup);
+
+				return rc;
+			}
+
+			host = next;
+		} while (host != NULL);
+
+		free(host_dup);
+	}
+
+	return SA_OK;
+}
+
+static int
+foreach_nfs_host(sa_share_impl_t impl_share, nfs_host_callback_t callback,
+    void *cookie)
+{
+	nfs_host_cookie_t udata;
+	char *shareopts;
+
+	udata.callback = callback;
+	udata.sharepath = impl_share-&gt;sharepath;
+	udata.cookie = cookie;
+	udata.security = &quot;sys&quot;;
+
+	shareopts = FSINFO(impl_share, nfs_fstype)-&gt;shareopts;
+
+	return foreach_nfs_shareopt(shareopts, foreach_nfs_host_cb,
+	    &amp;udata);
+}
+
+static int
+get_linux_hostspec(const char *solaris_hostspec, char **plinux_hostspec)
+{
+	/*
+	 * For now we just support CIDR masks (e.g. @192.168.0.0/16) and host
+	 * wildcards (e.g. *.example.org).
+	 */
+	if (solaris_hostspec[0] == '@') {
+		/*
+		 * Solaris host specifier, e.g. @192.168.0.0/16; we just need
+		 * to skip the @ in this case
+		 */
+		*plinux_hostspec = strdup(solaris_hostspec + 1);
+	} else {
+		*plinux_hostspec = strdup(solaris_hostspec);
+	}
+
+	if (*plinux_hostspec == NULL) {
+		return SA_NO_MEMORY;
+	}
+
+	return SA_OK;
+}
+
+static int
+nfs_enable_share_one(const char *sharepath, const char *host,
+    const char *security, const char *access, void *pcookie)
+{
+	pid_t pid;
+	int rc, status;
+	char *linuxhost, *hostpath, *opts;
+	const char *linux_opts = (const char *)pcookie;
+
+	pid = fork();
+
+	if (pid &lt; 0)
+		return SA_SYSTEM_ERR;
+
+	if (pid &gt; 0) {
+		while ((rc = waitpid(pid, &amp;status, 0)) &lt;= 0 &amp;&amp; errno == EINTR)
+			; /* empty loop body */
+
+		if (rc &lt;= 0)
+			return SA_SYSTEM_ERR;
+
+		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+			return SA_CONFIG_ERR;
+
+		return SA_OK;
+	}
+
+	/* child */
+
+	/* exportfs -i -o sec=XX,rX,&lt;opts&gt; &lt;host&gt;:&lt;sharepath&gt; */
+
+	rc = get_linux_hostspec(host, &amp;linuxhost);
+
+	if (rc &lt; 0)
+		exit(1);
+
+	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
+
+	if (hostpath == NULL) {
+		free(linuxhost);
+
+		exit(1);
+	}
+
+	sprintf(hostpath, &quot;%s:%s&quot;, linuxhost, sharepath);
+
+	free(linuxhost);
+
+	if (linux_opts == NULL)
+		linux_opts = &quot;&quot;;
+
+	opts = malloc(4 + strlen(security) + 4 + strlen(linux_opts) + 1);
+
+	if (opts == NULL)
+		exit(1);
+
+	sprintf(opts, &quot;sec=%s,%s,%s&quot;, security, access, linux_opts);
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;sharing %s with opts %s\n&quot;, hostpath, opts);
+#endif
+
+	rc = execlp(&quot;/usr/sbin/exportfs&quot;, &quot;exportfs&quot;, &quot;-i&quot;, \
+	    &quot;-o&quot;, opts, hostpath, NULL);
+
+	if (rc &lt; 0) {
+		free(hostpath);
+		free(opts);
+		exit(1);
+	}
+
+	exit(0);
+}
+
+static int
+add_linux_shareopt(char **plinux_opts, const char *key, const char *value)
+{
+	size_t len = 0;
+	char *new_linux_opts;
+
+	if (*plinux_opts != NULL)
+		len = strlen(*plinux_opts);
+
+	new_linux_opts = realloc(*plinux_opts, len + 1 + strlen(key) +
+	    (value ? 1 + strlen(value) : 0) + 1);
+
+	if (new_linux_opts == NULL)
+		return SA_NO_MEMORY;
+
+	new_linux_opts[len] = '\0';
+
+	if (len &gt; 0)
+		strcat(new_linux_opts, &quot;,&quot;);
+
+	strcat(new_linux_opts, key);
+
+	if (value != NULL) {
+		strcat(new_linux_opts, &quot;=&quot;);
+		strcat(new_linux_opts, value);
+	}
+
+	*plinux_opts = new_linux_opts;
+
+	return SA_OK;
+}
+
+static int
+get_linux_shareopts_cb(const char *key, const char *value, void *cookie)
+{
+	char **plinux_opts = (char **)cookie;
+
+	/* host-specific options, these are taken care of elsewhere */
+	if (strcmp(key, &quot;ro&quot;) == 0 || strcmp(key, &quot;rw&quot;) == 0 ||
+	    strcmp(key, &quot;sec&quot;) == 0)
+		return SA_OK;
+
+	if (strcmp(key, &quot;anon&quot;) == 0)
+		key = &quot;anonuid&quot;;
+
+	 if (strcmp(key, &quot;root_mapping&quot;) == 0) {
+		 (void) add_linux_shareopt(plinux_opts, &quot;root_squash&quot;, NULL);
+		 key = &quot;anonuid&quot;;
+	 }
+
+	if (strcmp(key, &quot;nosub&quot;) == 0)
+		key = &quot;subtree_check&quot;;
+
+	if (strcmp(key, &quot;insecure&quot;) != 0 &amp;&amp; strcmp(key, &quot;secure&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;async&quot;) != 0 &amp;&amp; strcmp(key, &quot;sync&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_wdelay&quot;) != 0 &amp;&amp; strcmp(key, &quot;wdelay&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;nohide&quot;) != 0 &amp;&amp; strcmp(key, &quot;hide&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;crossmnt&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_subtree_check&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;subtree_check&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;insecure_locks&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;secure_locks&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_auth_nlm&quot;) != 0 &amp;&amp; strcmp(key, &quot;auth_nlm&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_acl&quot;) != 0 &amp;&amp; strcmp(key, &quot;mountpoint&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;mp&quot;) != 0 &amp;&amp; strcmp(key, &quot;fsuid&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;refer&quot;) != 0 &amp;&amp; strcmp(key, &quot;replicas&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;root_squash&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_root_squash&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;all_squash&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;no_all_squash&quot;) != 0 &amp;&amp;
+	    strcmp(key, &quot;anonuid&quot;) != 0 &amp;&amp; strcmp(key, &quot;anongid&quot;) != 0) {
+		return SA_SYNTAX_ERR;
+	}
+
+	(void) add_linux_shareopt(plinux_opts, key, value);
+
+	return SA_OK;
+}
+
+static int
+get_linux_shareopts(const char *shareopts, char **plinux_opts)
+{
+	int rc;
+
+	assert(plinux_opts != NULL);
+
+	*plinux_opts = NULL;
+
+	/* default options for Solaris shares */
+	(void) add_linux_shareopt(plinux_opts, &quot;no_subtree_check&quot;, NULL);
+	(void) add_linux_shareopt(plinux_opts, &quot;no_root_squash&quot;, NULL);
+	(void) add_linux_shareopt(plinux_opts, &quot;mountpoint&quot;, NULL);
+
+	rc = foreach_nfs_shareopt(shareopts, get_linux_shareopts_cb, plinux_opts);
+
+	if (rc != SA_OK) {
+		free(*plinux_opts);
+		*plinux_opts = NULL;
+	}
+
+	return rc;
+}
+
+static int
+nfs_enable_share(sa_share_impl_t impl_share)
+{
+	char *shareopts, *linux_opts;
+	int rc;
+
+	if (!nfs_available) {
+		return SA_SYSTEM_ERR;
+	}
+
+	shareopts = FSINFO(impl_share, nfs_fstype)-&gt;shareopts;
+
+	if (shareopts == NULL)
+		return SA_OK;
+
+	rc = get_linux_shareopts(shareopts, &amp;linux_opts);
+
+	if (rc != SA_OK)
+		return rc;
+
+	rc = foreach_nfs_host(impl_share, nfs_enable_share_one, linux_opts);
+
+	free(linux_opts);
+
+	return rc;
+}
+
+static int
+nfs_disable_share_one(const char *sharepath, const char *host,
+    const char *security, const char *access, void *cookie)
+{
+	pid_t pid;
+	int rc, status;
+	char *linuxhost, *hostpath;
+
+	pid = fork();
+
+	if (pid &lt; 0)
+		return SA_SYSTEM_ERR;
+
+	if (pid &gt; 0) {
+		while ((rc = waitpid(pid, &amp;status, 0)) &lt;= 0 &amp;&amp; errno == EINTR)
+			; /* empty loop body */
+
+		if (rc &lt;= 0)
+			return SA_SYSTEM_ERR;
+
+		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+			return SA_CONFIG_ERR;
+
+		return SA_OK;
+	}
+
+	/* child */
+
+	rc = get_linux_hostspec(host, &amp;linuxhost);
+
+	if (rc &lt; 0)
+		exit(1);
+
+	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
+
+	if (hostpath == NULL) {
+		free(linuxhost);
+		exit(1);
+	}
+
+	sprintf(hostpath, &quot;%s:%s&quot;, linuxhost, sharepath);
+
+	free(linuxhost);
+
+#ifdef DEBUG
+	fprintf(stderr, &quot;unsharing %s\n&quot;, hostpath);
+#endif
+
+	rc = execlp(&quot;/usr/sbin/exportfs&quot;, &quot;exportfs&quot;, &quot;-u&quot;, \
+	    hostpath, NULL);
+
+	if (rc &lt; 0) {
+		free(hostpath);
+		exit(1);
+	}
+
+	exit(0);
+}
+
+static int
+nfs_disable_share(sa_share_impl_t impl_share)
+{
+	if (!nfs_available) {
</span><span class="stdout">+		/*
+		 * The share can't possibly be active, so nothing
+		 * needs to be done to disable it.
+		 */
+		return SA_OK;
+	}
+
+	return foreach_nfs_host(impl_share, nfs_disable_share_one, NULL);
+}
+
+static int
+nfs_validate_shareopts(const char *shareopts)
+{
+	char *linux_opts;
+	int rc;
+
+	rc = get_linux_shareopts(shareopts, &amp;linux_opts);
+
+	if (rc != SA_OK)
+		return rc;
+
+	free(linux_opts);
+
+	return SA_OK;
+}
+
+/*
+ * TODO: Rather than invoking &quot;exportfs -v&quot; once for each share we should only
+ * call it once for all shares.
+ */
+static boolean_t
+is_share_active(sa_share_impl_t impl_share)
+{
+	pid_t pid;
+	int rc, status;
+	int pipes[2];
+	FILE *exportfs_stdout;
+	char line[512];
+	char *tab, *cur;
+	boolean_t share_active = B_FALSE;
+
+	if (pipe(pipes) &lt; 0)
+		return B_FALSE;
+
+	pid = fork();
+
+	if (pid &lt; 0)
+		return B_FALSE;
+
+	if (pid &gt; 0) {
+		share_active = B_FALSE;
+
+		exportfs_stdout = fdopen(pipes[0], &quot;r&quot;);
+		close(pipes[1]);
+
+		while (fgets(line, sizeof(line), exportfs_stdout) != NULL) {
+			if (share_active)
+				continue;
+
+			/*
+			 * exportfs uses separate lines for the share path
+			 * and the export options when the share path is longer
+			 * than a certain amount of characters; this ignores
+			 * the option lines
+			 */
+			if (line[0] == '\t')
+				continue;
+
+			tab = strchr(line, '\t');
+
+			if (tab != NULL) {
+				*tab = '\0';
+				cur = tab - 1;
+			} else {
+				/*
+				 * there's no tab character, which means the
+				 * NFS options are on a separate line; we just
+				 * need to remove the new-line character
+				 * at the end of the line
+				 */
+				cur = line + strlen(line) - 1;
+			}
+
+			/* remove trailing spaces and new-line characters */
+			while (cur &gt;= line &amp;&amp;
+			    (*cur == ' ' || *cur == '\n'))
+				*cur-- = '\0';
+
+			if (strcmp(line, impl_share-&gt;sharepath) == 0) {
+				share_active = B_TRUE;
+
+				/*
+				 * We can't break here just yet, otherwise
+				 * exportfs might die due to write() failing
+				 * with EPIPE once we've closed the pipe file
+				 * descriptor - we need to read until EOF
+				 * occurs on the stdout pipe.
+				 */
+			}
+		}
+
+		fclose(exportfs_stdout);
+
+		while ((rc = waitpid(pid, &amp;status, 0)) &lt;= 0 &amp;&amp; errno == EINTR)
+			; /* empty loop body */
+
+		if (rc &lt;= 0)
+			return B_FALSE;
+
+		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+			return B_FALSE;
+
+		return share_active;
+	}
+
+	/* child */
+
+	/* exportfs -v */
+
+	close(pipes[0]);
+
+	if (dup2(pipes[1], STDOUT_FILENO) &lt; 0)
+		exit(1);
+
+	rc = execlp(&quot;/usr/sbin/exportfs&quot;, &quot;exportfs&quot;, &quot;-v&quot;, NULL);
+
+	if (rc &lt; 0) {
+		exit(1);
+	}
+
+	exit(0);
+}
+
+static int
+nfs_update_shareopts(sa_share_impl_t impl_share, const char *resource,
+    const char *shareopts)
+{
+	char *shareopts_dup;
+	boolean_t needs_reshare = B_FALSE;
+	char *old_shareopts;
+
+	FSINFO(impl_share, nfs_fstype)-&gt;active = is_share_active(impl_share);
+
+	old_shareopts = FSINFO(impl_share, nfs_fstype)-&gt;shareopts;
+
+	if (strcmp(shareopts, &quot;on&quot;) == 0)
+		shareopts = &quot;rw&quot;;
+
+	if (FSINFO(impl_share, nfs_fstype)-&gt;active &amp;&amp; old_shareopts != NULL &amp;&amp;
+	    strcmp(old_shareopts, shareopts) != 0) {
+		needs_reshare = B_TRUE;
+		nfs_disable_share(impl_share);
+	}
+
+	shareopts_dup = strdup(shareopts);
+
+	if (shareopts_dup == NULL)
+		return SA_NO_MEMORY;
+
+	if (old_shareopts != NULL)
+		free(old_shareopts);
+
+	FSINFO(impl_share, nfs_fstype)-&gt;shareopts = shareopts_dup;
+
+	if (needs_reshare)
+		nfs_enable_share(impl_share);
+
+	return SA_OK;
+}
+
+
+static void
+nfs_clear_shareopts(sa_share_impl_t impl_share)
+{
+	free(FSINFO(impl_share, nfs_fstype)-&gt;shareopts);
+	FSINFO(impl_share, nfs_fstype)-&gt;shareopts = NULL;
+}
+
+static const sa_share_ops_t nfs_shareops = {
+	.enable_share = nfs_enable_share,
+	.disable_share = nfs_disable_share,
+
+	.validate_shareopts = nfs_validate_shareopts,
+	.update_shareopts = nfs_update_shareopts,
+	.clear_shareopts = nfs_clear_shareopts,
+};
+
+static int
+nfs_check_exportfs(void)
+{
+	pid_t pid;
+	int rc, status, null_fd;
+
+	pid = fork();
+
+	if (pid &lt; 0)
+		return SA_SYSTEM_ERR;
+
+	if (pid &gt; 0) {
+		while ((rc = waitpid(pid, &amp;status, 0)) &lt;= 0 &amp;&amp; errno == EINTR)
+			; /* empty loop body */
+
+		if (rc &lt;= 0)
+			return SA_SYSTEM_ERR;
+
+		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+			return SA_CONFIG_ERR;
+
+		return SA_OK;
+	}
+
+	/* child */
+
+	null_fd = open(&quot;/dev/null&quot;, O_RDONLY);
+
+	if (null_fd &lt; 0 || dup2(null_fd, 1) &lt; 0 || dup2(null_fd, 2) &lt; 0)
+		exit(1);
+
+	close(null_fd);
+
+	rc = execlp(&quot;/usr/sbin/exportfs&quot;, &quot;exportfs&quot;, NULL);
+
+	if (rc &lt; 0) {
+		exit(1);
+	}
+
+	exit(0);
+}
+
+void
+libshare_nfs_init(void)
+{
+	nfs_available = (nfs_check_exportfs() == SA_OK);
+
+	nfs_fstype = register_fstype(&quot;nfs&quot;, &amp;nfs_shareops);
+}
diff --git a/lib/libshare/nfs.h b/lib/libshare/nfs.h
new file mode 100644
index 0000000..b9ea6ee
--- /dev/null
+++ b/lib/libshare/nfs.h
@@ -0,0 +1,27 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the &quot;License&quot;).
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011 Gunnar Beutner
+ */
+
+void libshare_nfs_init(void);
diff --git a/lib/libspl/Makefile.am b/lib/libspl/Makefile.am
index f95e42b..586e6c0 100644
--- a/lib/libspl/Makefile.am
+++ b/lib/libspl/Makefile.am
@@ -13,8 +13,6 @@ AM_CCASFLAGS = \
 
 lib_LTLIBRARIES = libspl.la
 
-libspl_la_LDFLAGS = -lrt
-
 libspl_la_SOURCES = \
 	$(top_srcdir)/lib/libspl/getexecname.c \
 	$(top_srcdir)/lib/libspl/gethrtime.c \
@@ -31,3 +29,5 @@ libspl_la_SOURCES = \
 	$(top_srcdir)/lib/libspl/$(TARGET_ASM_DIR)/atomic.S \
 	$(top_srcdir)/lib/libspl/include/sys/list.h \
 	$(top_srcdir)/lib/libspl/include/sys/list_impl.h
+
+libspl_la_LDFLAGS = -lrt -version-info 1:0:0
diff --git a/lib/libspl/Makefile.in b/lib/libspl/Makefile.in
index fa1ff51..8bfad8e 100644
--- a/lib/libspl/Makefile.in
+++ b/lib/libspl/Makefile.in
@@ -379,7 +379,6 @@ AM_CCASFLAGS = \
 	-I$(top_srcdir)/lib/libspl/include
 
 lib_LTLIBRARIES = libspl.la
-libspl_la_LDFLAGS = -lrt
 libspl_la_SOURCES = \
 	$(top_srcdir)/lib/libspl/getexecname.c \
 	$(top_srcdir)/lib/libspl/gethrtime.c \
@@ -397,6 +396,7 @@ libspl_la_SOURCES = \
 	$(top_srcdir)/lib/libspl/include/sys/list.h \
 	$(top_srcdir)/lib/libspl/include/sys/list_impl.h
 
+libspl_la_LDFLAGS = -lrt -version-info 1:0:0
 all: all-recursive
 
 .SUFFIXES:
diff --git a/lib/libspl/include/libshare.h b/lib/libspl/include/libshare.h
index f1fbfad..a35bfac 100644
--- a/lib/libspl/include/libshare.h
+++ b/lib/libspl/include/libshare.h
@@ -34,9 +34,63 @@ typedef void *sa_share_t;
 #define	SA_INIT_SHARE_API	0x0001	/* init share specific interface */
 #define	SA_INIT_CONTROL_API	0x0002	/* init control specific interface */
 
-/* Error values */
+/*
+ * defined error values
+ */
+
 #define	SA_OK			0
+#define	SA_NO_SUCH_PATH		1	/* provided path doesn't exist */
 #define	SA_NO_MEMORY		2	/* no memory for data structures */
+#define	SA_DUPLICATE_NAME	3	/* object name is already in use */
+#define	SA_BAD_PATH		4	/* not a full path */
+#define	SA_NO_SUCH_GROUP	5	/* group is not defined */
 #define	SA_CONFIG_ERR		6	/* system configuration error */
+#define	SA_SYSTEM_ERR		7	/* system error, use errno */
+#define	SA_SYNTAX_ERR		8	/* syntax error on command line */
+#define	SA_NO_PERMISSION	9	/* no permission for operation */
+#define	SA_BUSY			10	/* resource is busy */
+#define	SA_NO_SUCH_PROP		11	/* property doesn't exist */
+#define	SA_INVALID_NAME		12	/* name of object is invalid */
+#define	SA_INVALID_PROTOCOL	13	/* specified protocol not valid */
+#define	SA_NOT_ALLOWED		14	/* operation not allowed */
+#define	SA_BAD_VALUE		15	/* bad value for property */
+#define	SA_INVALID_SECURITY	16	/* invalid security type */
+#define	SA_NO_SUCH_SECURITY	17	/* security set not found */
+#define	SA_VALUE_CONFLICT	18	/* property value conflict */
+#define	SA_NOT_IMPLEMENTED	19	/* plugin interface not implemented */
+#define	SA_INVALID_PATH		20	/* path is sub-dir of existing share */
+#define	SA_NOT_SUPPORTED	21	/* operation not supported for proto */
+#define	SA_PROP_SHARE_ONLY	22	/* property valid on share only */
+#define	SA_NOT_SHARED		23	/* path is not shared */
+#define	SA_NO_SUCH_RESOURCE	24	/* resource not found */
+#define	SA_RESOURCE_REQUIRED	25	/* resource name is required  */
+#define	SA_MULTIPLE_ERROR	26	/* multiple protocols reported error */
+#define	SA_PATH_IS_SUBDIR	27	/* check_path found path is subdir */
+#define	SA_PATH_IS_PARENTDIR	28	/* check_path found path is parent */
+#define	SA_NO_SECTION		29	/* protocol requires section info */
+#define	SA_NO_SUCH_SECTION	30	/* no section found */
+#define	SA_NO_PROPERTIES	31	/* no properties found */
+#define	SA_PASSWORD_ENC		32	/* passwords must be encrypted */
+#define	SA_SHARE_EXISTS		33	/* path or file is already shared */
+
+/* initialization */
+extern sa_handle_t sa_init(int);
+extern void sa_fini(sa_handle_t);
+extern char *sa_errorstr(int);
+
+/* share control */
+extern sa_share_t sa_find_share(sa_handle_t, char *);
+extern int sa_enable_share(sa_group_t, char *);
+extern int sa_disable_share(sa_share_t, char *);
+
+/* protocol specific interfaces */
+extern int sa_parse_legacy_options(sa_group_t, char *, char *</span><span class="stdout">);
+
+/* ZFS functions */
+extern boolean_t sa_needs_refresh(sa_handle_t handle);
+libzfs_handle_t *sa_get_zfs_handle(sa_handle_t handle);
+extern int sa_zfs_process_share(sa_handle_t handle, sa_group_t group,
+    sa_share_t share, char *mountpoint, char *proto, zprop_source_t source,
+    char *shareopts, char *sourcestr, char *dataset);
 
 #endif /* _LIBSPL_LIBSHARE_H */
diff --git a/lib/libunicode/Makefile.am b/lib/libunicode/Makefile.am
index bdf0491..32be052 100644
--- a/lib/libunicode/Makefile.am
+++ b/lib/libunicode/Makefile.am
@@ -11,3 +11,5 @@ lib_LTLIBRARIES = libunicode.la
 libunicode_la_SOURCES = \
 	$(top_srcdir)/module/unicode/u8_textprep.c \
 	$(top_srcdir)/module/unicode/uconv.c
+
+libunicode_la_LDFLAGS = -version-info 1:0:0
diff --git a/lib/libunicode/Makefile.in b/lib/libunicode/Makefile.in
index 6d1ffb4..cef6504 100644
--- a/lib/libunicode/Makefile.in
+++ b/lib/libunicode/Makefile.in
@@ -116,6 +116,9 @@ libunicode_la_OBJECTS = $(am_libunicode_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
 am__v_lt_0 = --silent
+libunicode_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libunicode_la_LDFLAGS) $(LDFLAGS) -o $@
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -327,6 +330,7 @@ libunicode_la_SOURCES = \
 	$(top_srcdir)/module/unicode/u8_textprep.c \
 	$(top_srcdir)/module/unicode/uconv.c
 
+libunicode_la_LDFLAGS = -version-info 1:0:0
 all: all-am
 
 .SUFFIXES:
@@ -393,7 +397,7 @@ clean-libLTLIBRARIES:
 	  rm -f &quot;$${dir}/so_locations&quot;; \
 	done
 libunicode.la: $(libunicode_la_OBJECTS) $(libunicode_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) -rpath $(libdir) $(libunicode_la_OBJECTS) $(libunicode_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunicode_la_LINK) -rpath $(libdir) $(libunicode_la_OBJECTS) $(libunicode_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/lib/libuutil/Makefile.am b/lib/libuutil/Makefile.am
index 6ff181d..f073cdb 100644
--- a/lib/libuutil/Makefile.am
+++ b/lib/libuutil/Makefile.am
@@ -21,3 +21,5 @@ libuutil_la_SOURCES = \
 	$(top_srcdir)/lib/libuutil/uu_pname.c \
 	$(top_srcdir)/lib/libuutil/uu_string.c \
 	$(top_srcdir)/lib/libuutil/uu_strtoint.c
+
+libuutil_la_LDFLAGS = -version-info 1:0:0
diff --git a/lib/libuutil/Makefile.in b/lib/libuutil/Makefile.in
index 8678411..e0b3d94 100644
--- a/lib/libuutil/Makefile.in
+++ b/lib/libuutil/Makefile.in
@@ -118,6 +118,9 @@ libuutil_la_OBJECTS = $(am_libuutil_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
 am__v_lt_0 = --silent
+libuutil_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libuutil_la_LDFLAGS) $(LDFLAGS) -o $@
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
@@ -338,6 +341,7 @@ libuutil_la_SOURCES = \
 	$(top_srcdir)/lib/libuutil/uu_string.c \
 	$(top_srcdir)/lib/libuutil/uu_strtoint.c
 
+libuutil_la_LDFLAGS = -version-info 1:0:0
 all: all-am
 
 .SUFFIXES:
@@ -404,7 +408,7 @@ clean-libLTLIBRARIES:
 	  rm -f &quot;$${dir}/so_locations&quot;; \
 	done
 libuutil.la: $(libuutil_la_OBJECTS) $(libuutil_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) -rpath $(libdir) $(libuutil_la_OBJECTS) $(libuutil_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libuutil_la_LINK) -rpath $(libdir) $(libuutil_la_OBJECTS) $(libuutil_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/lib/libzfs/Makefile.am b/lib/libzfs/Makefile.am
index f239e7b..dfe87ed 100644
--- a/lib/libzfs/Makefile.am
+++ b/lib/libzfs/Makefile.am
@@ -6,12 +6,11 @@ DEFAULT_INCLUDES += \
 
 lib_LTLIBRARIES = libzfs.la
 
-libzfs_la_LDFLAGS = -lm -ldl $(LIBSELINUX)
-
 libzfs_la_LIBADD = \
 	$(top_builddir)/lib/libspl/libspl.la \
 	$(top_builddir)/lib/libefi/libefi.la \
 	$(top_builddir)/lib/libnvpair/libnvpair.la \
+	$(top_builddir)/lib/libshare/libshare.la \
 	$(top_builddir)/lib/libuutil/libuutil.la \
 	$(top_builddir)/lib/libzpool/libzpool.la
 
@@ -28,3 +27,5 @@ libzfs_la_SOURCES = \
 	$(top_srcdir)/lib/libzfs/libzfs_sendrecv.c \
 	$(top_srcdir)/lib/libzfs/libzfs_status.c \
 	$(top_srcdir)/lib/libzfs/libzfs_util.c
+
+libzfs_la_LDFLAGS = -lm -ldl $(LIBSELINUX) -version-info 1:0:0
diff --git a/lib/libzfs/Makefile.in b/lib/libzfs/Makefile.in
index 73ec605..b03caa6 100644
--- a/lib/libzfs/Makefile.in
+++ b/lib/libzfs/Makefile.in
@@ -113,6 +113,7 @@ LTLIBRARIES = $(lib_LTLIBRARIES)
 libzfs_la_DEPENDENCIES = $(top_builddir)/lib/libspl/libspl.la \
 	$(top_builddir)/lib/libefi/libefi.la \
 	$(top_builddir)/lib/libnvpair/libnvpair.la \
+	$(top_builddir)/lib/libshare/libshare.la \
 	$(top_builddir)/lib/libuutil/libuutil.la \
 	$(top_builddir)/lib/libzpool/libzpool.la
 am_libzfs_la_OBJECTS = libzfs_changelist.lo libzfs_config.lo \
@@ -332,11 +333,11 @@ AM_CFLAGS = -Wall -Wstrict-prototypes -fno-strict-aliasing \
 	-D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE \
 	-DTEXT_DOMAIN=\&quot;zfs-linux-user\&quot;
 lib_LTLIBRARIES = libzfs.la
-libzfs_la_LDFLAGS = -lm -ldl $(LIBSELINUX)
 libzfs_la_LIBADD = \
 	$(top_builddir)/lib/libspl/libspl.la \
 	$(top_builddir)/lib/libefi/libefi.la \
 	$(top_builddir)/lib/libnvpair/libnvpair.la \
+	$(top_builddir)/lib/libshare/libshare.la \
 	$(top_builddir)/lib/libuutil/libuutil.la \
 	$(top_builddir)/lib/libzpool/libzpool.la
 
@@ -354,6 +355,7 @@ libzfs_la_SOURCES = \
 	$(top_srcdir)/lib/libzfs/libzfs_status.c \
 	$(top_srcdir)/lib/libzfs/libzfs_util.c
 
+libzfs_la_LDFLAGS = -lm -ldl $(LIBSELINUX) -version-info 1:0:0
 all: all-am
 
 .SUFFIXES:
diff --git a/lib/libzfs/libzfs_mount.c b/lib/libzfs/libzfs_mount.c
index 6b70cbb..6758f6a 100644
--- a/lib/libzfs/libzfs_mount.c
+++ b/lib/libzfs/libzfs_mount.c
@@ -117,21 +117,20 @@ zfs_share_proto_t share_all_proto[] = {
 };
 
 /*
- * Search for NFS and SMB exports for the given mountpoint and protocol, returning
+ * Search the sharetab for the given mountpoint and protocol, returning
  * a zfs_share_type_t value.
  */
 static zfs_share_type_t
 is_shared(libzfs_handle_t *hdl, const char *mountpoint, zfs_share_proto_t proto)
 {
 	char buf[MAXPATHLEN], *tab;
+	char *ptr;
 
 	if (hdl-&gt;libzfs_sharetab == NULL)
 		return (SHARED_NOT_SHARED);
 
 	(void) fseek(hdl-&gt;libzfs_sharetab, 0, SEEK_SET);
 
-	/* Search /etc/exports for NFS exports */
-	/* FIXME: Assumes the file is tab delimited. */
 	while (fgets(buf, sizeof (buf), hdl-&gt;libzfs_sharetab) != NULL) {
 
 		/* the mountpoint is the first entry on each line */
@@ -140,15 +139,31 @@ is_shared(libzfs_handle_t *hdl, const char *mountpoint, zfs_share_proto_t proto)
 
 		*tab = '\0';
 		if (strcmp(buf, mountpoint) == 0) {
-			if (proto == PROTO_NFS)
-				return (SHARED_NFS);
-			else
-				return (SHARED_NOT_SHARED);
+			/*
+			 * the protocol field is the third field
+			 * skip over second field
+			 */
+			ptr = ++tab;
+			if ((tab = strchr(ptr, '\t')) == NULL)
+				continue;
+			ptr = ++tab;
+			if ((tab = strchr(ptr, '\t')) == NULL)
+				continue;
+			*tab = '\0';
+			if (strcmp(ptr,
+			    proto_table[proto].p_name) == 0) {
+				switch (proto) {
+				case PROTO_NFS:
+					return (SHARED_NFS);
+				case PROTO_SMB:
+					return (SHARED_SMB);
+				default:
+					return (0);
+				}
+			}
 		}
 	}
 
-	/* XXX: Search /etc/samba/smb.conf for SMB exports, return SHARED_SMB */
-
 	return (SHARED_NOT_SHARED);
 }
 
@@ -627,97 +642,6 @@ zfs_is_shared_smb(zfs_handle_t *zhp, char **where)
 }
 
 /*
- * Make sure things will work if libshare isn't installed by using
- * wrapper functions that check to see that the pointers to functions
- * initialized in _zfs_init_libshare() are actually present.
- */
-
-static sa_handle_t (*_sa_init)(int);
-static void (*_sa_fini)(sa_handle_t);
-static sa_share_t (*_sa_find_share)(sa_handle_t, char *);
-static int (*_sa_enable_share)(sa_share_t, char *);
-static int (*_sa_disable_share)(sa_share_t, char *);
-static char *(*_sa_errorstr)(int);
-static int (*_sa_parse_legacy_options)(sa_group_t, char *, char *);
-static boolean_t (*_sa_needs_refresh)(sa_handle_t *);
-static libzfs_handle_t *(*_sa_get_zfs_handle)(sa_handle_t);
-static int (*_sa_zfs_process_share)(sa_handle_t, sa_group_t, sa_share_t,
-    char *, char *, zprop_source_t, char *, char *, char *);
-static void (*_sa_update_sharetab_ts)(sa_handle_t);
-
-/*
- * _zfs_init_libshare()
- *
- * Find the libshare.so.1 entry points that we use here and save the
- * values to be used later. This is triggered by the runtime loader.
- * Make sure the correct ISA version is loaded.
- */
-#ifdef __GNUC__
-static void
-_zfs_init_libshare(void) __attribute__((constructor));
-#else
-#pragma init(_zfs_init_libshare)
-#endif
-static void
-_zfs_init_libshare(void)
-{
-	void *libshare;
-	char path[MAXPATHLEN];
-	char isa[MAXISALEN];
-
-#if defined(_LP64)
-	if (sysinfo(SI_ARCHITECTURE_64, isa, MAXISALEN) == -1)
-		isa[0] = '\0';
-#else
-	isa[0] = '\0';
-#endif
-	(void) snprintf(path, MAXPATHLEN,
-	    &quot;/usr/lib/%s/libshare.so.1&quot;, isa);
-
-	if ((libshare = dlopen(path, RTLD_LAZY | RTLD_GLOBAL)) != NULL) {
-		_sa_init = (sa_handle_t (*)(int))dlsym(libshare, &quot;sa_init&quot;);
-		_sa_fini = (void (*)(sa_handle_t))dlsym(libshare, &quot;sa_fini&quot;);
-		_sa_find_share = (sa_share_t (*)(sa_handle_t, char *))
-		    dlsym(libshare, &quot;sa_find_share&quot;);
-		_sa_enable_share = (int (*)(sa_share_t, char *))dlsym(libshare,
-		    &quot;sa_enable_share&quot;);
-		_sa_disable_share = (int (*)(sa_share_t, char *))dlsym(libshare,
-		    &quot;sa_disable_share&quot;);
-		_sa_errorstr = (char *(*)(int))dlsym(libshare, &quot;sa_errorstr&quot;);
-		_sa_parse_legacy_options = (int (*)(sa_group_t, char *, char *))
-		    dlsym(libshare, &quot;sa_parse_legacy_options&quot;);
-		_sa_needs_refresh = (boolean_t (*)(sa_handle_t *))
-		    dlsym(libshare, &quot;sa_needs_refresh&quot;);
-		_sa_get_zfs_handle = (libzfs_handle_t *(*)(sa_handle_t))
-		    dlsym(libshare, &quot;sa_get_zfs_handle&quot;);
-		_sa_zfs_process_share = (int (*)(sa_handle_t, sa_group_t,
-		    sa_share_t, char </span><span class="stdout">*, char *, zprop_source_t, char *,
-		    char *, char *))dlsym(libshare, &quot;sa_zfs_process_share&quot;);
-		_sa_update_sharetab_ts = (void (*)(sa_handle_t))
-		    dlsym(libshare, &quot;sa_update_sharetab_ts&quot;);
-		if (_sa_init == NULL || _sa_fini == NULL ||
-		    _sa_find_share == NULL || _sa_enable_share == NULL ||
-		    _sa_disable_share == NULL || _sa_errorstr == NULL ||
-		    _sa_parse_legacy_options == NULL ||
-		    _sa_needs_refresh == NULL || _sa_get_zfs_handle == NULL ||
-		    _sa_zfs_process_share == NULL ||
-		    _sa_update_sharetab_ts == NULL) {
-			_sa_init = NULL;
-			_sa_fini = NULL;
-			_sa_disable_share = NULL;
-			_sa_enable_share = NULL;
-			_sa_errorstr = NULL;
-			_sa_parse_legacy_options = NULL;
-			(void) dlclose(libshare);
-			_sa_needs_refresh = NULL;
-			_sa_get_zfs_handle = NULL;
-			_sa_zfs_process_share = NULL;
-			_sa_update_sharetab_ts = NULL;
-		}
-	}
-}
-
-/*
  * zfs_init_libshare(zhandle, service)
  *
  * Initialize the libshare API if it hasn't already been initialized.
@@ -730,9 +654,6 @@ zfs_init_libshare(libzfs_handle_t *zhandle, int service)
 {
 	int ret = SA_OK;
 
-	if (_sa_init == NULL)
-		ret = SA_CONFIG_ERR;
-
 	if (ret == SA_OK &amp;&amp; zhandle-&gt;libzfs_shareflags &amp; ZFSSHARE_MISS) {
 		/*
 		 * We had a cache miss. Most likely it is a new ZFS
@@ -743,15 +664,14 @@ zfs_init_libshare(libzfs_handle_t *zhandle, int service)
 		 * internal cache.
 		 */
 		zhandle-&gt;libzfs_shareflags &amp;= ~ZFSSHARE_MISS;
-		if (_sa_needs_refresh != NULL &amp;&amp;
-		    _sa_needs_refresh(zhandle-&gt;libzfs_sharehdl)) {
+		if (sa_needs_refresh(zhandle-&gt;libzfs_sharehdl)) {
 			zfs_uninit_libshare(zhandle);
-			zhandle-&gt;libzfs_sharehdl = _sa_init(service);
+			zhandle-&gt;libzfs_sharehdl = sa_init(service);
 		}
 	}
 
 	if (ret == SA_OK &amp;&amp; zhandle &amp;&amp; zhandle-&gt;libzfs_sharehdl == NULL)
-		zhandle-&gt;libzfs_sharehdl = _sa_init(service);
+		zhandle-&gt;libzfs_sharehdl = sa_init(service);
 
 	if (ret == SA_OK &amp;&amp; zhandle-&gt;libzfs_sharehdl == NULL)
 		ret = SA_NO_MEMORY;
@@ -769,8 +689,7 @@ void
 zfs_uninit_libshare(libzfs_handle_t *zhandle)
 {
 	if (zhandle != NULL &amp;&amp; zhandle-&gt;libzfs_sharehdl != NULL) {
-		if (_sa_fini != NULL)
-			_sa_fini(zhandle-&gt;libzfs_sharehdl);
+		sa_fini(zhandle-&gt;libzfs_sharehdl);
 		zhandle-&gt;libzfs_sharehdl = NULL;
 	}
 }
@@ -784,53 +703,8 @@ zfs_uninit_libshare(libzfs_handle_t *zhandle)
 int
 zfs_parse_options(char *options, zfs_share_proto_t proto)
 {
-	if (_sa_parse_legacy_options != NULL) {
-		return (_sa_parse_legacy_options(NULL, options,
-		    proto_table[proto].p_name));
-	}
-	return (SA_CONFIG_ERR);
-}
-
-/*
- * zfs_sa_find_share(handle, path)
- *
- * wrapper around sa_find_share to find a share path in the
- * configuration.
- */
-static sa_share_t
-zfs_sa_find_share(sa_handle_t handle, char *path)
-{
-	if (_sa_find_share != NULL)
-		return (_sa_find_share(handle, path));
-	return (NULL);
-}
-
-/*
- * zfs_sa_enable_share(share, proto)
- *
- * Wrapper for sa_enable_share which enables a share for a specified
- * protocol.
- */
-static int
-zfs_sa_enable_share(sa_share_t share, char *proto)
-{
-	if (_sa_enable_share != NULL)
-		return (_sa_enable_share(share, proto));
-	return (SA_CONFIG_ERR);
-}
-
-/*
- * zfs_sa_disable_share(share, proto)
- *
- * Wrapper for sa_enable_share which disables a share for a specified
- * protocol.
- */
-static int
-zfs_sa_disable_share(sa_share_t share, char *proto)
-{
-	if (_sa_disable_share != NULL)
-		return (_sa_disable_share(share, proto));
-	return (SA_CONFIG_ERR);
+	return (sa_parse_legacy_options(NULL, options,
+	    proto_table[proto].p_name));
 }
 
 /*
@@ -854,14 +728,10 @@ zfs_share_proto(zfs_handle_t *zhp, zfs_share_proto_t *proto)
 		return (0);
 
 	if ((ret = zfs_init_libshare(hdl, SA_INIT_SHARE_API)) != SA_OK) {
-#ifdef HAVE_SHARE
 		(void) zfs_error_fmt(hdl, EZFS_SHARENFSFAILED,
 		    dgettext(TEXT_DOMAIN, &quot;cannot share '%s': %s&quot;),
-		    zfs_get_name(zhp), _sa_errorstr != NULL ?
-		    _sa_errorstr(ret) : &quot;&quot;);
+		    zfs_get_name(zhp), sa_errorstr(ret));
 		return (-1);
-#endif /* HAVE_SHARE */
-		return (0);
 	}
 
 	for (curr_proto = proto; *curr_proto != PROTO_END; curr_proto++) {
@@ -883,7 +753,7 @@ zfs_share_proto(zfs_handle_t *zhp, zfs_share_proto_t *proto)
 		if (zfs_prop_get_int(zhp, ZFS_PROP_ZONED))
 			continue;
 
-		share = zfs_sa_find_share(hdl-&gt;libzfs_sharehdl, mountpoint);
+		share = sa_find_share(hdl-&gt;libzfs_sharehdl, mountpoint);
 		if (share == NULL) {
 			/*
 			 * This may be a new file system that was just
@@ -894,7 +764,7 @@ zfs_share_proto(zfs_handle_t *zhp, zfs_share_proto_t *proto)
 			 * safe to add this to the internal
 			 * configuration.
 			 */
-			if (_sa_zfs_process_share(hdl-&gt;libzfs_sharehdl,
+			if (sa_zfs_process_share(hdl-&gt;libzfs_sharehdl,
 			    NULL, NULL, mountpoint,
 			    proto_table[*curr_proto].p_name, sourcetype,
 			    shareopts, sourcestr, zhp-&gt;zfs_name) != SA_OK) {
@@ -905,12 +775,12 @@ zfs_share_proto(zfs_handle_t *zhp, zfs_share_proto_t *proto)
 				return (-1);
 			}
 			hdl-&gt;libzfs_shareflags |= ZFSSHARE_MISS;
-			share = zfs_sa_find_share(hdl-&gt;libzfs_sharehdl,
+			share = sa_find_share(hdl-&gt;libzfs_sharehdl,
 			    mountpoint);
 		}
 		if (share != NULL) {
 			int err;
-			err = zfs_sa_enable_share(share,
+			err = sa_enable_share(share,
 			    proto_table[*curr_proto].p_name);
 			if (err != SA_OK) {
 				(void) zfs_error_fmt(hdl,
@@ -972,18 +842,18 @@ unshare_one(libzfs_handle_t *hdl, const char *name, const char *mountpoint,
 		free(mntpt);	/* don't need the copy anymore */
 		return (zfs_error_fmt(hdl, EZFS_SHARENFSFAILED,
 		    dgettext(TEXT_DOMAIN, &quot;cannot unshare '%s': %s&quot;),
-		    name, _sa_errorstr(err)));
+		    name, sa_errorstr(err)));
 	}
 
-	share = zfs_sa_find_share(hdl-&gt;libzfs_sharehdl, mntpt);
+	share = sa_find_share(hdl-&gt;libzfs_sharehdl, mntpt);
 	free(mntpt);	/* don't need the copy anymore */
 
 	if (share != NULL) {
-		err = zfs_sa_disable_share(share, proto_table[proto].p_name);
+		err = sa_disable_share(share, proto_table[proto].p_name);
 		if (err != SA_OK) {
 			return (zfs_error_fmt(hdl, EZFS_UNSHARENFSFAILED,
 			    dgettext(TEXT_DOMAIN, &quot;cannot unshare '%s': %s&quot;),
-			    name, _sa_errorstr(err)));
+			    name, sa_errorstr(err)));
 		}
 	} else {
 		return (zfs_error_fmt(hdl, EZFS_UNSHARENFSFAILED,
diff --git a/lib/libzpool/Makefile.am b/lib/libzpool/Makefile.am
index da89e29..a9a7a1e 100644
--- a/lib/libzpool/Makefile.am
+++ b/lib/libzpool/Makefile.am
@@ -93,7 +93,7 @@ libzpool_la_SOURCES = \
 	$(top_srcdir)/module/zfs/zle.c \
 	$(top_srcdir)/module/zfs/zrlock.c
 
-libzpool_la_LDFLAGS = -pthread
+libzpool_la_LDFLAGS = -pthread -version-info 1:0:0
 
 EXTRA_DIST = \
 	$(top_srcdir)/module/zfs/vdev_disk.c \
diff --git a/lib/libzpool/Makefile.in b/lib/libzpool/Makefile.in
index db27fd5..6d0f0d9 100644
--- a/lib/libzpool/Makefile.in
+++ b/lib/libzpool/Makefile.in
@@ -429,7 +429,7 @@ libzpool_la_SOURCES = \
 	$(top_srcdir)/module/zfs/zle.c \
 	$(top_srcdir)/module/zfs/zrlock.c
 
-libzpool_la_LDFLAGS = -pthread
+libzpool_la_LDFLAGS = -pthread -version-info 1:0:0
 EXTRA_DIST = \
 	$(top_srcdir)/module/zfs/vdev_disk.c \
 	$(top_srcdir)/module/zfs/zfs_acl.c \
diff --git a/module/zfs/zfs_ioctl.c b/module/zfs/zfs_ioctl.c
index b50f023..e378d8e 100644
--- a/module/zfs/zfs_ioctl.c
+++ b/module/zfs/zfs_ioctl.c
@@ -591,7 +591,7 @@ zfs_secpolicy_send(zfs_cmd_t *zc, cred_t *cr)
 	return (error);
 }
 
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 static int
 zfs_secpolicy_deleg_share(zfs_cmd_t *zc, cred_t *cr)
 {
@@ -615,12 +615,12 @@ zfs_secpolicy_deleg_share(zfs_cmd_t *zc, cred_t *cr)
 	return (dsl_deleg_access(zc-&gt;zc_name,
 	    ZFS_DELEG_PERM_SHARE, cr));
 }
-#endif /* HAVE_SHARE */
+#endif /* HAVE_SMB_SHARE */
 
 int
 zfs_secpolicy_share(zfs_cmd_t *zc, cred_t *cr)
 {
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 	if (!INGLOBALZONE(curproc))
 		return (EPERM);
 
@@ -631,13 +631,13 @@ zfs_secpolicy_share(zfs_cmd_t *zc, cred_t *cr)
 	}
 #else
 	return (ENOTSUP);
-#endif /* HAVE_SHARE */
+#endif /* HAVE_SMB_SHARE */
 }
 
 int
 zfs_secpolicy_smb_acl(zfs_cmd_t *zc, cred_t *cr)
 {
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 	if (!INGLOBALZONE(curproc))
 		return (EPERM);
 
@@ -648,7 +648,7 @@ zfs_secpolicy_smb_acl(zfs_cmd_t *zc, cred_t *cr)
 	}
 #else
 	return (ENOTSUP);
-#endif /* HAVE_SHARE */
+#endif /* HAVE_SMB_SHARE */
 }
 
 static int
@@ -4152,143 +4152,10 @@ zfs_ioc_userspace_upgrade(zfs_cmd_t *zc)
 	return (error);
 }
 
-/*
- * We don't want to have a hard dependency
- * against some special symbols in sharefs
- * nfs, and smbsrv.  Determine them if needed when
- * the first file system is shared.
- * Neither sharefs, nfs or smbsrv are unloadable modules.
- */
-#ifdef HAVE_SHARE
-int (*znfsexport_fs)(void *arg);
-int (*zshare_fs)(enum sharefs_sys_op, share_t *, uint32_t);
-int (*zsmbexport_fs)(void *arg, boolean_t add_share);
-
-int zfs_nfsshare_inited;
-int zfs_smbshare_inited;
-
-ddi_modhandle_t nfs_mod;
-ddi_modhandle_t sharefs_mod;
-ddi_modhandle_t smbsrv_mod;
-kmutex_t zfs_share_lock;
-
-static int
-zfs_init_sharefs()
-{
-	int error;
-
-	ASSERT(MUTEX_HELD(&amp;zfs_share_lock));
-	/* Both NFS and SMB shares also require sharetab support. */
-	if (sharefs_mod == NULL &amp;&amp; ((sharefs_mod =
-	    ddi_modopen(&quot;fs/sharefs&quot;,
-	    KRTLD_MODE_FIRST, &amp;error)) == NULL)) {
-		return (ENOSYS);
-	}
-	if (zshare_fs == NULL &amp;&amp; ((zshare_fs =
-	    (int (*)(enum sharefs_sys_op, share_t *, uint32_t))
-	    ddi_modsym(sharefs_mod, &quot;sharefs_impl&quot;, &amp;error)) == NULL)) {
-		return (ENOSYS);
-	}
-	return (0);
-}
-#endif /* HAVE_SHARE */
-
 static int
 zfs_ioc_share(zfs_cmd_t *zc)
 {
-#ifdef HAVE_SHARE
-	int error;
-	int opcode;
-
-	switch (zc-&gt;zc_share.z_sharetype) {
-	case ZFS_SHARE_NFS:
-	case ZFS_UNSHARE_NFS:
-		if (zfs_nfsshare_inited == 0) {
-			mutex_enter(&amp;zfs_share_lock);
-			if (nfs_mod == NULL &amp;&amp; ((nfs_mod = ddi_modopen(&quot;fs/nfs&quot;,
-			    KRTLD_MODE_FIRST, &amp;error)) == NULL)) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			if (znfsexport_fs == NULL &amp;&amp;
-			    ((znfsexport_fs = (int </span><span class="stdout">(*)(void *))
-			    ddi_modsym(nfs_mod,
-			    &quot;nfs_export&quot;, &amp;error)) == NULL)) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			error = zfs_init_sharefs();
-			if (error) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			zfs_nfsshare_inited = 1;
-			mutex_exit(&amp;zfs_share_lock);
-		}
-		break;
-	case ZFS_SHARE_SMB:
-	case ZFS_UNSHARE_SMB:
-		if (zfs_smbshare_inited == 0) {
-			mutex_enter(&amp;zfs_share_lock);
-			if (smbsrv_mod == NULL &amp;&amp; ((smbsrv_mod =
-			    ddi_modopen(&quot;drv/smbsrv&quot;,
-			    KRTLD_MODE_FIRST, &amp;error)) == NULL)) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			if (zsmbexport_fs == NULL &amp;&amp; ((zsmbexport_fs =
-			    (int (*)(void *, boolean_t))ddi_modsym(smbsrv_mod,
-			    &quot;smb_server_share&quot;, &amp;error)) == NULL)) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			error = zfs_init_sharefs();
-			if (error) {
-				mutex_exit(&amp;zfs_share_lock);
-				return (ENOSYS);
-			}
-			zfs_smbshare_inited = 1;
-			mutex_exit(&amp;zfs_share_lock);
-		}
-		break;
-	default:
-		return (EINVAL);
-	}
-
-	switch (zc-&gt;zc_share.z_sharetype) {
-	case ZFS_SHARE_NFS:
-	case ZFS_UNSHARE_NFS:
-		if (error =
-		    znfsexport_fs((void *)
-		    (uintptr_t)zc-&gt;zc_share.z_exportdata))
-			return (error);
-		break;
-	case ZFS_SHARE_SMB:
-	case ZFS_UNSHARE_SMB:
-		if (error = zsmbexport_fs((void *)
-		    (uintptr_t)zc-&gt;zc_share.z_exportdata,
-		    zc-&gt;zc_share.z_sharetype == ZFS_SHARE_SMB ?
-		    B_TRUE: B_FALSE)) {
-			return (error);
-		}
-		break;
-	}
-
-	opcode = (zc-&gt;zc_share.z_sharetype == ZFS_SHARE_NFS ||
-	    zc-&gt;zc_share.z_sharetype == ZFS_SHARE_SMB) ?
-	    SHAREFS_ADD : SHAREFS_REMOVE;
-
-	/*
-	 * Add or remove share from sharetab
-	 */
-	error = zshare_fs(opcode,
-	    (void *)(uintptr_t)zc-&gt;zc_share.z_sharedata,
-	    zc-&gt;zc_share.z_sharemax);
-
-	return (error);
-#else
-	return (ENOTSUP);
-#endif /* HAVE_SHARE */
+	return (ENOSYS);
 }
 
 ace_t full_access[] = {
@@ -4405,7 +4272,7 @@ zfs_ioc_diff(zfs_cmd_t *zc)
 /*
  * Remove all ACL files in shares dir
  */
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 static int
 zfs_smb_acl_purge(znode_t *dzp)
 {
@@ -4424,12 +4291,12 @@ zfs_smb_acl_purge(znode_t *dzp)
 	zap_cursor_fini(&amp;zc);
 	return (error);
 }
-#endif /* HAVE SHARE */
+#endif /* HAVE_SMB_SHARE */
 
 static int
 zfs_ioc_smb_acl(zfs_cmd_t *zc)
 {
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 	vnode_t *vp;
 	znode_t *dzp;
 	vnode_t *resourcevp = NULL;
@@ -4553,7 +4420,7 @@ zfs_ioc_smb_acl(zfs_cmd_t *zc)
 	return (error);
 #else
 	return (ENOTSUP);
-#endif /* HAVE_SHARE */
+#endif /* HAVE_SMB_SHARE */
 }
 
 /*
@@ -5175,10 +5042,6 @@ _init(void)
 	tsd_create(&amp;zfs_fsyncer_key, NULL);
 	tsd_create(&amp;rrw_tsd_key, NULL);
 
-#ifdef HAVE_SHARE
-	mutex_init(&amp;zfs_share_lock, NULL, MUTEX_DEFAULT, NULL);
-#endif /* HAVE_SHARE */
-
 	printk(KERN_NOTICE &quot;ZFS: Loaded module v%s%s, &quot;
 	       &quot;ZFS pool version %s, ZFS filesystem version %s\n&quot;,
 	       ZFS_META_VERSION, ZFS_DEBUG_STR,
@@ -5204,16 +5067,7 @@ _fini(void)
 	zvol_fini();
 	zfs_fini();
 	spa_fini();
-#ifdef HAVE_SHARE
-	if (zfs_nfsshare_inited)
-		(void) ddi_modclose(nfs_mod);
-	if (zfs_smbshare_inited)
-		(void) ddi_modclose(smbsrv_mod);
-	if (zfs_nfsshare_inited || zfs_smbshare_inited)
-		(void) ddi_modclose(sharefs_mod);
-
-	mutex_destroy(&amp;zfs_share_lock);
-#endif /* HAVE_SHARE */
+
 	tsd_destroy(&amp;zfs_fsyncer_key);
 	tsd_destroy(&amp;rrw_tsd_key);
 
diff --git a/module/zfs/zfs_znode.c b/module/zfs/zfs_znode.c
index a51d5e6..b56e290 100644
--- a/module/zfs/zfs_znode.c
+++ b/module/zfs/zfs_znode.c
@@ -161,7 +161,7 @@ zfs_znode_fini(void)
 int
 zfs_create_share_dir(zfs_sb_t *zsb, dmu_tx_t *tx)
 {
-#ifdef HAVE_SHARE
+#ifdef HAVE_SMB_SHARE
 	zfs_acl_ids_t acl_ids;
 	vattr_t vattr;
 	znode_t *sharezp;
@@ -203,7 +203,7 @@ zfs_create_share_dir(zfs_sb_t *zsb, dmu_tx_t *tx)
 	return (error);
 #else
 	return (0);
-#endif /* HAVE_SHARE */
+#endif /* HAVE_SMB_SHARE */
 }
 
 static void
</span></pre>
</body>
<!-- Mirrored from pip.chaos:8010/builders/TOSS%202.0%20Desktop%20-%20AMD64/builds/70/steps/git/logs/patch by HTTrack Website Copier/3.x [XR&CO'2010], Fri, 08 Jul 2011 00:43:47 GMT -->
</html>
